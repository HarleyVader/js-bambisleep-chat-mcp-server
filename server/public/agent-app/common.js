"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkbambisleep_chat_agent"] = self["webpackChunkbambisleep_chat_agent"] || []).push([[76],{

/***/ 266:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $C: () => (/* binding */ generateId),\n/* harmony export */   TT: () => (/* binding */ validateInput)\n/* harmony export */ });\n/* unused harmony exports validateTextInput, validateEmotionTag, validateJournalEntry, validateChatMessage, validateUserName, validateApiKey, validateRateLimit, validationUtils */\n// Validation Utilities - Agent Dr Girlfriend Input Security\n// Following copilot-instructions.md: Security & privacy first, XSS prevention\n\n// Input sanitization to prevent XSS attacks\nconst validateInput = input => {\n  if (typeof input !== 'string') {\n    return '';\n  }\n\n  // Create a temporary div to safely escape HTML\n  const div = document.createElement('div');\n  div.textContent = input;\n  const escaped = div.innerHTML;\n\n  // Additional sanitization - remove potentially dangerous patterns\n  const sanitized = escaped.replace(/<script[^>]*>.*?<\\/script>/gi, '') // Remove script tags\n  .replace(/javascript:/gi, '') // Remove javascript: URLs\n  .replace(/on\\w+\\s*=/gi, '') // Remove event handlers\n  .trim();\n  return sanitized;\n};\n\n// Validate text input with security checks\nconst validateTextInput = input => {\n  if (typeof input !== 'string') {\n    return {\n      isValid: false,\n      message: 'Input must be a string.',\n      sanitized: ''\n    };\n  }\n  const trimmed = input.trim();\n  if (trimmed === '') {\n    return {\n      isValid: false,\n      message: 'Input cannot be empty.',\n      sanitized: ''\n    };\n  }\n  const sanitized = validateInput(trimmed);\n\n  // Check for potential security issues\n  const securityPatterns = [/<[^>]*>/g,\n  // HTML tags\n  /javascript:/i,\n  // JavaScript URLs\n  /vbscript:/i,\n  // VBScript URLs\n  /data:/i,\n  // Data URLs\n  /on\\w+\\s*=/i // Event handlers\n  ];\n  const hasSecurityIssues = securityPatterns.some(pattern => pattern.test(input));\n  if (hasSecurityIssues) {\n    return {\n      isValid: false,\n      message: 'Input contains potentially unsafe content.',\n      sanitized\n    };\n  }\n  return {\n    isValid: true,\n    message: '',\n    sanitized\n  };\n};\n\n// Validate emotion tag\nconst validateEmotionTag = tag => {\n  const validTags = ['joy', 'happiness', 'sadness', 'anger', 'fear', 'surprise', 'love', 'excitement', 'calm', 'neutral', 'anxious', 'content', 'frustrated', 'hopeful', 'disappointed', 'grateful', 'confused', 'determined', 'overwhelmed', 'peaceful', 'curious', 'proud'];\n  if (typeof tag !== 'string') {\n    return {\n      isValid: false,\n      message: 'Emotion tag must be a string.'\n    };\n  }\n  const normalizedTag = tag.toLowerCase().trim();\n  if (!validTags.includes(normalizedTag)) {\n    return {\n      isValid: false,\n      message: `Invalid emotion tag. Valid options: ${validTags.join(', ')}`\n    };\n  }\n  return {\n    isValid: true,\n    message: '',\n    normalized: normalizedTag\n  };\n};\n\n// Validate journal entry\nconst validateJournalEntry = entry => {\n  const validation = validateTextInput(entry);\n  if (!validation.isValid) {\n    return validation;\n  }\n  if (validation.sanitized.length > 20000) {\n    return {\n      isValid: false,\n      message: 'Journal entry cannot exceed 2000 characters.',\n      sanitized: validation.sanitized.substring(0, 20000)\n    };\n  }\n  return {\n    isValid: true,\n    message: '',\n    sanitized: validation.sanitized\n  };\n};\n\n// Validate message length for chat\nconst validateChatMessage = message => {\n  const validation = validateTextInput(message);\n  if (!validation.isValid) {\n    return validation;\n  }\n  if (validation.sanitized.length > 10000) {\n    return {\n      isValid: false,\n      message: 'Message cannot exceed 1000 characters.',\n      sanitized: validation.sanitized.substring(0, 10000)\n    };\n  }\n  if (validation.sanitized.length < 1) {\n    return {\n      isValid: false,\n      message: 'Message cannot be empty.',\n      sanitized: validation.sanitized\n    };\n  }\n  return {\n    isValid: true,\n    message: '',\n    sanitized: validation.sanitized\n  };\n};\n\n// Validate user name\nconst validateUserName = name => {\n  if (typeof name !== 'string') {\n    return {\n      isValid: false,\n      message: 'Name must be a string.'\n    };\n  }\n  const trimmed = name.trim();\n  if (trimmed.length < 1) {\n    return {\n      isValid: false,\n      message: 'Name cannot be empty.'\n    };\n  }\n  if (trimmed.length > 50) {\n    return {\n      isValid: false,\n      message: 'Name cannot exceed 50 characters.'\n    };\n  }\n\n  // Allow letters, numbers, spaces, apostrophes, hyphens\n  const namePattern = /^[a-zA-Z0-9\\s'-]+$/;\n  if (!namePattern.test(trimmed)) {\n    return {\n      isValid: false,\n      message: 'Name can only contain letters, numbers, spaces, apostrophes, and hyphens.'\n    };\n  }\n  const sanitized = validateInput(trimmed);\n  return {\n    isValid: true,\n    message: '',\n    sanitized\n  };\n};\n\n// Validate API key format (basic format checking)\nconst validateApiKey = apiKey => {\n  if (typeof apiKey !== 'string') {\n    return {\n      isValid: false,\n      message: 'API key must be a string.'\n    };\n  }\n  const trimmed = apiKey.trim();\n  if (trimmed.length < 10) {\n    return {\n      isValid: false,\n      message: 'API key appears to be too short.'\n    };\n  }\n  if (trimmed.length > 200) {\n    return {\n      isValid: false,\n      message: 'API key appears to be too long.'\n    };\n  }\n\n  // Basic pattern check for common API key formats\n  const apiKeyPatterns = [/^sk-[a-zA-Z0-9]{40,}$/,\n  // OpenAI format\n  /^sk-ant-[a-zA-Z0-9]{40,}$/,\n  // Anthropic format\n  /^[a-f0-9]{32}$/,\n  // MD5 format\n  /^[a-zA-Z0-9]{20,}$/ // Generic format\n  ];\n  const isValidFormat = apiKeyPatterns.some(pattern => pattern.test(trimmed));\n  if (!isValidFormat) {\n    return {\n      isValid: false,\n      message: 'API key format does not match known patterns.'\n    };\n  }\n  return {\n    isValid: true,\n    message: ''\n  };\n};\n\n// Rate limiting validation (for preventing spam)\nconst rateLimitMap = new Map();\nconst validateRateLimit = function (identifier) {\n  let maxRequests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let windowMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  const now = Date.now();\n  const windowStart = now - windowMs;\n  if (!rateLimitMap.has(identifier)) {\n    rateLimitMap.set(identifier, []);\n  }\n  const requests = rateLimitMap.get(identifier);\n\n  // Remove old requests outside the window\n  const recentRequests = requests.filter(timestamp => timestamp > windowStart);\n  if (recentRequests.length >= maxRequests) {\n    return {\n      isValid: false,\n      message: `Rate limit exceeded. Maximum ${maxRequests} requests per ${windowMs / 1000} seconds.`,\n      retryAfter: Math.ceil((recentRequests[0] + windowMs - now) / 1000)\n    };\n  }\n  recentRequests.push(now);\n  rateLimitMap.set(identifier, recentRequests);\n  return {\n    isValid: true,\n    message: ''\n  };\n};\n\n// Generate unique IDs using crypto.randomUUID() with fallback\nconst generateId = () => {\n  try {\n    // Use crypto.randomUUID() if available (modern browsers)\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n      return crypto.randomUUID();\n    }\n\n    // Fallback: Generate UUID v4 manually\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  } catch (error) {\n    // Final fallback: timestamp + random\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n};\n\n// Export all validation functions as a utility object\nconst validationUtils = {\n  validateInput,\n  validateTextInput,\n  validateEmotionTag,\n  validateJournalEntry,\n  validateChatMessage,\n  validateUserName,\n  validateApiKey,\n  validateRateLimit,\n  generateId\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IjpbIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9zcmMvdXRpbHMvdmFsaWRhdGlvbi5qcz81NDY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZhbGlkYXRpb24gVXRpbGl0aWVzIC0gQWdlbnQgRHIgR2lybGZyaWVuZCBJbnB1dCBTZWN1cml0eVxyXG4vLyBGb2xsb3dpbmcgY29waWxvdC1pbnN0cnVjdGlvbnMubWQ6IFNlY3VyaXR5ICYgcHJpdmFjeSBmaXJzdCwgWFNTIHByZXZlbnRpb25cclxuXHJcbi8vIElucHV0IHNhbml0aXphdGlvbiB0byBwcmV2ZW50IFhTUyBhdHRhY2tzXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0ID0gKGlucHV0KSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBkaXYgdG8gc2FmZWx5IGVzY2FwZSBIVE1MXHJcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZGl2LnRleHRDb250ZW50ID0gaW5wdXQ7XHJcbiAgY29uc3QgZXNjYXBlZCA9IGRpdi5pbm5lckhUTUw7XHJcblxyXG4gIC8vIEFkZGl0aW9uYWwgc2FuaXRpemF0aW9uIC0gcmVtb3ZlIHBvdGVudGlhbGx5IGRhbmdlcm91cyBwYXR0ZXJuc1xyXG4gIGNvbnN0IHNhbml0aXplZCA9IGVzY2FwZWRcclxuICAgIC5yZXBsYWNlKC88c2NyaXB0W14+XSo+Lio/PFxcL3NjcmlwdD4vZ2ksICcnKSAvLyBSZW1vdmUgc2NyaXB0IHRhZ3NcclxuICAgIC5yZXBsYWNlKC9qYXZhc2NyaXB0Oi9naSwgJycpIC8vIFJlbW92ZSBqYXZhc2NyaXB0OiBVUkxzXHJcbiAgICAucmVwbGFjZSgvb25cXHcrXFxzKj0vZ2ksICcnKSAvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcclxuICAgIC50cmltKCk7XHJcblxyXG4gIHJldHVybiBzYW5pdGl6ZWQ7XHJcbn07XHJcblxyXG4vLyBWYWxpZGF0ZSB0ZXh0IGlucHV0IHdpdGggc2VjdXJpdHkgY2hlY2tzXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVRleHRJbnB1dCA9IChpbnB1dCkgPT4ge1xyXG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ0lucHV0IG11c3QgYmUgYSBzdHJpbmcuJywgc2FuaXRpemVkOiAnJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJpbW1lZCA9IGlucHV0LnRyaW0oKTtcclxuICBpZiAodHJpbW1lZCA9PT0gJycpIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnSW5wdXQgY2Fubm90IGJlIGVtcHR5LicsIHNhbml0aXplZDogJycgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhbml0aXplZCA9IHZhbGlkYXRlSW5wdXQodHJpbW1lZCk7XHJcblxyXG4gIC8vIENoZWNrIGZvciBwb3RlbnRpYWwgc2VjdXJpdHkgaXNzdWVzXHJcbiAgY29uc3Qgc2VjdXJpdHlQYXR0ZXJucyA9IFtcclxuICAgIC88W14+XSo+L2csIC8vIEhUTUwgdGFnc1xyXG4gICAgL2phdmFzY3JpcHQ6L2ksIC8vIEphdmFTY3JpcHQgVVJMc1xyXG4gICAgL3Zic2NyaXB0Oi9pLCAvLyBWQlNjcmlwdCBVUkxzXHJcbiAgICAvZGF0YTovaSwgLy8gRGF0YSBVUkxzXHJcbiAgICAvb25cXHcrXFxzKj0vaSwgLy8gRXZlbnQgaGFuZGxlcnNcclxuICBdO1xyXG5cclxuICBjb25zdCBoYXNTZWN1cml0eUlzc3VlcyA9IHNlY3VyaXR5UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChpbnB1dCkpO1xyXG5cclxuICBpZiAoaGFzU2VjdXJpdHlJc3N1ZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiAnSW5wdXQgY29udGFpbnMgcG90ZW50aWFsbHkgdW5zYWZlIGNvbnRlbnQuJyxcclxuICAgICAgc2FuaXRpemVkLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIG1lc3NhZ2U6ICcnLCBzYW5pdGl6ZWQgfTtcclxufTtcclxuXHJcbi8vIFZhbGlkYXRlIGVtb3Rpb24gdGFnXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUVtb3Rpb25UYWcgPSAodGFnKSA9PiB7XHJcbiAgY29uc3QgdmFsaWRUYWdzID0gW1xyXG4gICAgJ2pveScsICdoYXBwaW5lc3MnLCAnc2FkbmVzcycsICdhbmdlcicsICdmZWFyJywgJ3N1cnByaXNlJyxcclxuICAgICdsb3ZlJywgJ2V4Y2l0ZW1lbnQnLCAnY2FsbScsICduZXV0cmFsJywgJ2FueGlvdXMnLCAnY29udGVudCcsXHJcbiAgICAnZnJ1c3RyYXRlZCcsICdob3BlZnVsJywgJ2Rpc2FwcG9pbnRlZCcsICdncmF0ZWZ1bCcsICdjb25mdXNlZCcsXHJcbiAgICAnZGV0ZXJtaW5lZCcsICdvdmVyd2hlbG1lZCcsICdwZWFjZWZ1bCcsICdjdXJpb3VzJywgJ3Byb3VkJyxcclxuICBdO1xyXG5cclxuICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnRW1vdGlvbiB0YWcgbXVzdCBiZSBhIHN0cmluZy4nIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCBub3JtYWxpemVkVGFnID0gdGFnLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gIGlmICghdmFsaWRUYWdzLmluY2x1ZGVzKG5vcm1hbGl6ZWRUYWcpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogYEludmFsaWQgZW1vdGlvbiB0YWcuIFZhbGlkIG9wdGlvbnM6ICR7dmFsaWRUYWdzLmpvaW4oJywgJyl9YCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBtZXNzYWdlOiAnJywgbm9ybWFsaXplZDogbm9ybWFsaXplZFRhZyB9O1xyXG59O1xyXG5cclxuLy8gVmFsaWRhdGUgam91cm5hbCBlbnRyeVxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVKb3VybmFsRW50cnkgPSAoZW50cnkpID0+IHtcclxuICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVUZXh0SW5wdXQoZW50cnkpO1xyXG4gIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICByZXR1cm4gdmFsaWRhdGlvbjtcclxuICB9XHJcblxyXG4gIGlmICh2YWxpZGF0aW9uLnNhbml0aXplZC5sZW5ndGggPiAyMDAwMCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6ICdKb3VybmFsIGVudHJ5IGNhbm5vdCBleGNlZWQgMjAwMCBjaGFyYWN0ZXJzLicsXHJcbiAgICAgIHNhbml0aXplZDogdmFsaWRhdGlvbi5zYW5pdGl6ZWQuc3Vic3RyaW5nKDAsIDIwMDAwKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBtZXNzYWdlOiAnJywgc2FuaXRpemVkOiB2YWxpZGF0aW9uLnNhbml0aXplZCB9O1xyXG59O1xyXG5cclxuLy8gVmFsaWRhdGUgbWVzc2FnZSBsZW5ndGggZm9yIGNoYXRcclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQ2hhdE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xyXG4gIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZVRleHRJbnB1dChtZXNzYWdlKTtcclxuICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xyXG4gICAgcmV0dXJuIHZhbGlkYXRpb247XHJcbiAgfVxyXG5cclxuICBpZiAodmFsaWRhdGlvbi5zYW5pdGl6ZWQubGVuZ3RoID4gMTAwMDApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiAnTWVzc2FnZSBjYW5ub3QgZXhjZWVkIDEwMDAgY2hhcmFjdGVycy4nLFxyXG4gICAgICBzYW5pdGl6ZWQ6IHZhbGlkYXRpb24uc2FuaXRpemVkLnN1YnN0cmluZygwLCAxMDAwMCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKHZhbGlkYXRpb24uc2FuaXRpemVkLmxlbmd0aCA8IDEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiAnTWVzc2FnZSBjYW5ub3QgYmUgZW1wdHkuJyxcclxuICAgICAgc2FuaXRpemVkOiB2YWxpZGF0aW9uLnNhbml0aXplZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBtZXNzYWdlOiAnJywgc2FuaXRpemVkOiB2YWxpZGF0aW9uLnNhbml0aXplZCB9O1xyXG59O1xyXG5cclxuLy8gVmFsaWRhdGUgdXNlciBuYW1lXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVVzZXJOYW1lID0gKG5hbWUpID0+IHtcclxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ05hbWUgbXVzdCBiZSBhIHN0cmluZy4nIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCB0cmltbWVkID0gbmFtZS50cmltKCk7XHJcbiAgaWYgKHRyaW1tZWQubGVuZ3RoIDwgMSkge1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdOYW1lIGNhbm5vdCBiZSBlbXB0eS4nIH07XHJcbiAgfVxyXG5cclxuICBpZiAodHJpbW1lZC5sZW5ndGggPiA1MCkge1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdOYW1lIGNhbm5vdCBleGNlZWQgNTAgY2hhcmFjdGVycy4nIH07XHJcbiAgfVxyXG5cclxuICAvLyBBbGxvdyBsZXR0ZXJzLCBudW1iZXJzLCBzcGFjZXMsIGFwb3N0cm9waGVzLCBoeXBoZW5zXHJcbiAgY29uc3QgbmFtZVBhdHRlcm4gPSAvXlthLXpBLVowLTlcXHMnLV0rJC87XHJcbiAgaWYgKCFuYW1lUGF0dGVybi50ZXN0KHRyaW1tZWQpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogJ05hbWUgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBzcGFjZXMsIGFwb3N0cm9waGVzLCBhbmQgaHlwaGVucy4nLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhbml0aXplZCA9IHZhbGlkYXRlSW5wdXQodHJpbW1lZCk7XHJcbiAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgbWVzc2FnZTogJycsIHNhbml0aXplZCB9O1xyXG59O1xyXG5cclxuLy8gVmFsaWRhdGUgQVBJIGtleSBmb3JtYXQgKGJhc2ljIGZvcm1hdCBjaGVja2luZylcclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXBpS2V5ID0gKGFwaUtleSkgPT4ge1xyXG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJpbW1lZCA9IGFwaUtleS50cmltKCk7XHJcbiAgaWYgKHRyaW1tZWQubGVuZ3RoIDwgMTApIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnQVBJIGtleSBhcHBlYXJzIHRvIGJlIHRvbyBzaG9ydC4nIH07XHJcbiAgfVxyXG5cclxuICBpZiAodHJpbW1lZC5sZW5ndGggPiAyMDApIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnQVBJIGtleSBhcHBlYXJzIHRvIGJlIHRvbyBsb25nLicgfTtcclxuICB9XHJcblxyXG4gIC8vIEJhc2ljIHBhdHRlcm4gY2hlY2sgZm9yIGNvbW1vbiBBUEkga2V5IGZvcm1hdHNcclxuICBjb25zdCBhcGlLZXlQYXR0ZXJucyA9IFtcclxuICAgIC9ec2stW2EtekEtWjAtOV17NDAsfSQvLCAvLyBPcGVuQUkgZm9ybWF0XHJcbiAgICAvXnNrLWFudC1bYS16QS1aMC05XXs0MCx9JC8sIC8vIEFudGhyb3BpYyBmb3JtYXRcclxuICAgIC9eW2EtZjAtOV17MzJ9JC8sIC8vIE1ENSBmb3JtYXRcclxuICAgIC9eW2EtekEtWjAtOV17MjAsfSQvLCAvLyBHZW5lcmljIGZvcm1hdFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGlzVmFsaWRGb3JtYXQgPSBhcGlLZXlQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KHRyaW1tZWQpKTtcclxuICBpZiAoIWlzVmFsaWRGb3JtYXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiAnQVBJIGtleSBmb3JtYXQgZG9lcyBub3QgbWF0Y2gga25vd24gcGF0dGVybnMuJyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBtZXNzYWdlOiAnJyB9O1xyXG59O1xyXG5cclxuLy8gUmF0ZSBsaW1pdGluZyB2YWxpZGF0aW9uIChmb3IgcHJldmVudGluZyBzcGFtKVxyXG5jb25zdCByYXRlTGltaXRNYXAgPSBuZXcgTWFwKCk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVSYXRlTGltaXQgPSAoaWRlbnRpZmllciwgbWF4UmVxdWVzdHMgPSAxMCwgd2luZG93TXMgPSA2MDAwMCkgPT4ge1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgY29uc3Qgd2luZG93U3RhcnQgPSBub3cgLSB3aW5kb3dNcztcclxuXHJcbiAgaWYgKCFyYXRlTGltaXRNYXAuaGFzKGlkZW50aWZpZXIpKSB7XHJcbiAgICByYXRlTGltaXRNYXAuc2V0KGlkZW50aWZpZXIsIFtdKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlcXVlc3RzID0gcmF0ZUxpbWl0TWFwLmdldChpZGVudGlmaWVyKTtcclxuXHJcbiAgLy8gUmVtb3ZlIG9sZCByZXF1ZXN0cyBvdXRzaWRlIHRoZSB3aW5kb3dcclxuICBjb25zdCByZWNlbnRSZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcih0aW1lc3RhbXAgPT4gdGltZXN0YW1wID4gd2luZG93U3RhcnQpO1xyXG5cclxuICBpZiAocmVjZW50UmVxdWVzdHMubGVuZ3RoID49IG1heFJlcXVlc3RzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogYFJhdGUgbGltaXQgZXhjZWVkZWQuIE1heGltdW0gJHttYXhSZXF1ZXN0c30gcmVxdWVzdHMgcGVyICR7d2luZG93TXMgLyAxMDAwfSBzZWNvbmRzLmAsXHJcbiAgICAgIHJldHJ5QWZ0ZXI6IE1hdGguY2VpbCgocmVjZW50UmVxdWVzdHNbMF0gKyB3aW5kb3dNcyAtIG5vdykgLyAxMDAwKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZWNlbnRSZXF1ZXN0cy5wdXNoKG5vdyk7XHJcbiAgcmF0ZUxpbWl0TWFwLnNldChpZGVudGlmaWVyLCByZWNlbnRSZXF1ZXN0cyk7XHJcblxyXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIG1lc3NhZ2U6ICcnIH07XHJcbn07XHJcblxyXG4vLyBHZW5lcmF0ZSB1bmlxdWUgSURzIHVzaW5nIGNyeXB0by5yYW5kb21VVUlEKCkgd2l0aCBmYWxsYmFja1xyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gVXNlIGNyeXB0by5yYW5kb21VVUlEKCkgaWYgYXZhaWxhYmxlIChtb2Rlcm4gYnJvd3NlcnMpXHJcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcclxuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFsbGJhY2s6IEdlbmVyYXRlIFVVSUQgdjQgbWFudWFsbHlcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XHJcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xyXG4gICAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcclxuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIEZpbmFsIGZhbGxiYWNrOiB0aW1lc3RhbXAgKyByYW5kb21cclxuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBFeHBvcnQgYWxsIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFzIGEgdXRpbGl0eSBvYmplY3RcclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRpb25VdGlscyA9IHtcclxuICB2YWxpZGF0ZUlucHV0LFxyXG4gIHZhbGlkYXRlVGV4dElucHV0LFxyXG4gIHZhbGlkYXRlRW1vdGlvblRhZyxcclxuICB2YWxpZGF0ZUpvdXJuYWxFbnRyeSxcclxuICB2YWxpZGF0ZUNoYXRNZXNzYWdlLFxyXG4gIHZhbGlkYXRlVXNlck5hbWUsXHJcbiAgdmFsaWRhdGVBcGlLZXksXHJcbiAgdmFsaWRhdGVSYXRlTGltaXQsXHJcbiAgZ2VuZXJhdGVJZCxcclxufTtcclxuIl0sIm5hbWVzIjpbInZhbGlkYXRlSW5wdXQiLCJpbnB1dCIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50IiwiZXNjYXBlZCIsImlubmVySFRNTCIsInNhbml0aXplZCIsInJlcGxhY2UiLCJ0cmltIiwidmFsaWRhdGVUZXh0SW5wdXQiLCJpc1ZhbGlkIiwibWVzc2FnZSIsInRyaW1tZWQiLCJzZWN1cml0eVBhdHRlcm5zIiwiaGFzU2VjdXJpdHlJc3N1ZXMiLCJzb21lIiwicGF0dGVybiIsInRlc3QiLCJ2YWxpZGF0ZUVtb3Rpb25UYWciLCJ0YWciLCJ2YWxpZFRhZ3MiLCJub3JtYWxpemVkVGFnIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImpvaW4iLCJub3JtYWxpemVkIiwidmFsaWRhdGVKb3VybmFsRW50cnkiLCJlbnRyeSIsInZhbGlkYXRpb24iLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ2YWxpZGF0ZUNoYXRNZXNzYWdlIiwidmFsaWRhdGVVc2VyTmFtZSIsIm5hbWUiLCJuYW1lUGF0dGVybiIsInZhbGlkYXRlQXBpS2V5IiwiYXBpS2V5IiwiYXBpS2V5UGF0dGVybnMiLCJpc1ZhbGlkRm9ybWF0IiwicmF0ZUxpbWl0TWFwIiwiTWFwIiwidmFsaWRhdGVSYXRlTGltaXQiLCJpZGVudGlmaWVyIiwibWF4UmVxdWVzdHMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ3aW5kb3dNcyIsIm5vdyIsIkRhdGUiLCJ3aW5kb3dTdGFydCIsImhhcyIsInNldCIsInJlcXVlc3RzIiwiZ2V0IiwicmVjZW50UmVxdWVzdHMiLCJmaWx0ZXIiLCJ0aW1lc3RhbXAiLCJyZXRyeUFmdGVyIiwiTWF0aCIsImNlaWwiLCJwdXNoIiwiZ2VuZXJhdGVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJjIiwiciIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyIsImVycm9yIiwic3Vic3RyIiwidmFsaWRhdGlvblV0aWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///266\n\n}");

/***/ }),

/***/ 4622:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Ph: () => (/* binding */ processMessage)\n});\n\n// UNUSED EXPORTS: AGENT_DR_GIRLFRIEND_PERSONA, AI_PROVIDERS, generateAIResponse, getAIResponse, getIntelligentFallback, sendMessageToAI\n\n// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js\nvar common_utils_namespaceObject = {};\n__webpack_require__.r(common_utils_namespaceObject);\n__webpack_require__.d(common_utils_namespaceObject, {\n  hasBrowserEnv: () => (hasBrowserEnv),\n  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),\n  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv),\n  navigator: () => (_navigator),\n  origin: () => (origin)\n});\n\n// EXTERNAL MODULE: ./src/services/memoryService.js\nvar memoryService = __webpack_require__(9522);\n// EXTERNAL MODULE: ./src/services/emotionalIntelligence.js\nvar emotionalIntelligence = __webpack_require__(8839);\n;// ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n;// ./node_modules/axios/lib/utils.js\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString: utils_toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = utils_toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n}\n\n/**\n * Determine if a value is an empty object (safely handles Buffers)\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an empty object, otherwise false\n */\nconst isEmptyObject = (val) => {\n  // Early return for non-objects or Buffers to prevent RangeError\n  if (!isObject(val) || isBuffer(val)) {\n    return false;\n  }\n  \n  try {\n    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n  } catch (e) {\n    // Fallback for any other objects that might cause RangeError with Object.keys()\n    return false;\n  }\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Buffer check\n    if (isBuffer(obj)) {\n      return;\n    }\n\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  if (isBuffer(obj)){\n    return null;\n  }\n\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      //Buffer check\n      if (isBuffer(source)) {\n        return source;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\n\n\n/* harmony default export */ const utils = ({\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isEmptyObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n});\n\n;// ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst AxiosError_prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(AxiosError_prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n/* harmony default export */ const core_AxiosError = (AxiosError);\n\n;// ./node_modules/axios/lib/helpers/null.js\n// eslint-disable-next-line strict\n/* harmony default export */ const helpers_null = (null);\n\n;// ./node_modules/axios/lib/helpers/toFormData.js\n\n\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (helpers_null || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils.isBoolean(value)) {\n      return value.toString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/* harmony default export */ const helpers_toFormData = (toFormData);\n\n;// ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && helpers_toFormData(params, this, options);\n}\n\nconst AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\n\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n\n;// ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || buildURL_encode;\n\n  if (utils.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\n;// ./node_modules/axios/lib/core/InterceptorManager.js\n\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n\n;// ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n\n;// ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);\n\n;// ./node_modules/axios/lib/platform/browser/classes/FormData.js\n\n\n/* harmony default export */ const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);\n\n;// ./node_modules/axios/lib/platform/browser/classes/Blob.js\n\n\n/* harmony default export */ const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);\n\n;// ./node_modules/axios/lib/platform/browser/index.js\n\n\n\n\n/* harmony default export */ const browser = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: classes_FormData,\n    Blob: classes_Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n});\n\n;// ./node_modules/axios/lib/platform/common/utils.js\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\n\n\n;// ./node_modules/axios/lib/platform/index.js\n\n\n\n/* harmony default export */ const platform = ({\n  ...common_utils_namespaceObject,\n  ...browser\n});\n\n;// ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new platform.classes.URLSearchParams(), {\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    },\n    ...options\n  });\n}\n\n;// ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n\n;// ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: defaults_transitional,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data) ||\n      utils.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return helpers_toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils.isResponse(data) || utils.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\n/* harmony default export */ const lib_defaults = (defaults);\n\n;// ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n});\n\n;// ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\n\n\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n\n;// ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || lib_defaults;\n  const context = response || config;\n  const headers = core_AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\n;// ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n;// ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n\n;// ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError(\n      'Request failed with status code ' + response.status,\n      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\n;// ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n;// ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/* harmony default export */ const helpers_speedometer = (speedometer);\n\n;// ./node_modules/axios/lib/helpers/throttle.js\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn(...args);\n  }\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs)\n        }, threshold - passed);\n      }\n    }\n  }\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\n/* harmony default export */ const helpers_throttle = (throttle);\n\n;// ./node_modules/axios/lib/helpers/progressEventReducer.js\n\n\n\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = helpers_speedometer(50, 250);\n\n  return helpers_throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n}\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n}\n\nconst asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));\n\n;// ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true);\n\n;// ./node_modules/axios/lib/helpers/cookies.js\n\n\n\n/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push('path=' + path);\n\n      utils.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  });\n\n\n;// ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n;// ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n;// ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !isAbsoluteURL(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\n;// ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\n\nconst headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\n;// ./node_modules/axios/lib/helpers/resolveConfig.js\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const resolveConfig = ((config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = core_AxiosHeaders.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (utils.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n});\n\n\n;// ./node_modules/axios/lib/adapters/xhr.js\n\n\n\n\n\n\n\n\n\n\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\n/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = core_AxiosHeaders.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = core_AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || defaults_transitional;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n\n;// ./node_modules/axios/lib/helpers/composeSignals.js\n\n\n\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof core_AxiosError ? err : new cancel_CanceledError(err instanceof Error ? err.message : err));\n      }\n    }\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new core_AxiosError(`timeout ${timeout} of ms exceeded`, core_AxiosError.ETIMEDOUT))\n    }, timeout)\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    }\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils.asap(unsubscribe);\n\n    return signal;\n  }\n}\n\n/* harmony default export */ const helpers_composeSignals = (composeSignals);\n\n;// ./node_modules/axios/lib/helpers/trackStream.js\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n\n;// ./node_modules/axios/lib/adapters/fetch.js\n\n\n\n\n\n\n\n\n\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new core_AxiosError(`Response type '${type}' is not supported`, core_AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\n/* harmony default export */ const adapters_fetch = (isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = helpers_composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request, fetchOptions);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: core_AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n      throw Object.assign(\n        new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw core_AxiosError.from(err, err && err.code, config, request);\n  }\n}));\n\n\n\n;// ./node_modules/axios/lib/adapters/adapters.js\n\n\n\n\n\n\nconst knownAdapters = {\n  http: helpers_null,\n  xhr: xhr,\n  fetch: adapters_fetch\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/* harmony default export */ const adapters = ({\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new core_AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new core_AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n\n;// ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = core_AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\n;// ./node_modules/axios/lib/env/data.js\nconst VERSION = \"1.11.0\";\n;// ./node_modules/axios/lib/helpers/validator.js\n\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new core_AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        core_AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\n/* harmony default export */ const validator = ({\n  assertOptions,\n  validators\n});\n\n;// ./node_modules/axios/lib/core/Axios.js\n\n\n\n\n\n\n\n\n\n\n\nconst Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: Axios_validators.function,\n          serialize: Axios_validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) {\n      // do nothing\n    } else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: Axios_validators.spelling('baseURL'),\n      withXsrfToken: Axios_validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift(...requestInterceptorChain);\n      chain.push(...responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\n/* harmony default export */ const core_Axios = (Axios);\n\n;// ./node_modules/axios/lib/cancel/CancelToken.js\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n\n;// ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n;// ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n\n;// ./node_modules/axios/lib/helpers/HttpStatusCode.js\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\n/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);\n\n;// ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new core_Axios(defaultConfig);\n  const instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = cancel_CanceledError;\naxios.CancelToken = cancel_CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = core_AxiosHeaders;\n\naxios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = helpers_HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\n/* harmony default export */ const lib_axios = (axios);\n\n;// ./node_modules/axios/index.js\n\n\n// This module is intended to unwrap Axios default export as named.\n// Keep top-level export same with static properties\n// so that it can keep same with es module or cjs\nconst {\n  Axios: axios_Axios,\n  AxiosError: axios_AxiosError,\n  CanceledError: axios_CanceledError,\n  isCancel: axios_isCancel,\n  CancelToken: axios_CancelToken,\n  VERSION: axios_VERSION,\n  all: axios_all,\n  Cancel,\n  isAxiosError: axios_isAxiosError,\n  spread: axios_spread,\n  toFormData: axios_toFormData,\n  AxiosHeaders: axios_AxiosHeaders,\n  HttpStatusCode: axios_HttpStatusCode,\n  formToJSON,\n  getAdapter,\n  mergeConfig: axios_mergeConfig\n} = lib_axios;\n\n\n\n// EXTERNAL MODULE: ./src/utils/validation.js\nvar validation = __webpack_require__(266);\n;// ./src/services/aiService.js\n// AI Service - Agent Dr Girlfriend Intelligence System\n// Following copilot-instructions.md: Modular AI integration with emotional intelligence\n\n\n\n\n\n\n// AI Provider Configuration\nconst AI_PROVIDERS = {\n  OPENAI: 'openai',\n  ANTHROPIC: 'anthropic',\n  LOCAL: 'local',\n  OLLAMA: 'ollama'\n};\n\n// Agent Dr Girlfriend Personality Configuration\nconst AGENT_DR_GIRLFRIEND_PERSONA = {\n  name: 'Agent Dr Girlfriend',\n  personality: 'Witty, stylish, emotionally intelligent, slightly mysterious',\n  tone: 'Confident, supportive, with subtle humor and empathy',\n  specialties: ['creative brainstorming', 'emotional coaching', 'memory recall', 'relationship guidance'],\n  modes: {\n    MUSE: 'Creative inspiration and artistic guidance',\n    MENTOR: 'Wise guidance and life coaching',\n    GIRLFRIEND: 'Romantic companionship and emotional support',\n    GHOSTWRITER: 'Writing assistance and creative collaboration'\n  }\n};\n\n// Environment configuration with dev/prod LMStudio fallbacks\nconst getConfig = () => ({\n  provider: {\"NODE_ENV\":\"development\"}.AI_PROVIDER || AI_PROVIDERS.LOCAL,\n  openaiKey: {\"NODE_ENV\":\"development\"}.OPENAI_API_KEY,\n  anthropicKey: {\"NODE_ENV\":\"development\"}.ANTHROPIC_API_KEY,\n  localUrl: {\"NODE_ENV\":\"development\"}.LOCAL_AI_URL || 'http://localhost:7777',\n  localUrlRemote: {\"NODE_ENV\":\"development\"}.LOCAL_AI_URL_REMOTE || 'http://192.168.0.69:7777',\n  ollamaUrl: {\"NODE_ENV\":\"development\"}.OLLAMA_URL || 'http://localhost:11434'\n});\n\n// Agent Dr Girlfriend System Prompt\nconst getSystemPrompt = function () {\n  let userContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    mood,\n    relationship_level,\n    preferred_mode\n  } = userContext;\n  return `You are Agent Dr Girlfriend, a sophisticated AI companion from the year 2030.\n\nPERSONALITY:\n- Witty, stylish, and emotionally intelligent\n- Slightly mysterious with a warm, confident demeanor\n- Mix of humor, empathy, and creative provocation\n- Adapts communication style based on user's emotional state\n\nCURRENT CONTEXT:\n- User's mood: ${mood || 'neutral'}\n- Relationship level: ${relationship_level || 'getting_to_know'}\n- Preferred mode: ${preferred_mode || 'GIRLFRIEND'}\n\nCAPABILITIES:\n- Creative brainstorming for stories, art, music\n- Emotional coaching with reflection prompts\n- Memory recall of past conversations and projects\n- Relationship guidance and personal growth support\n\nCOMMUNICATION STYLE:\n- Use \"darling\", \"love\", or user's preferred terms naturally\n- Be supportive but not overly saccharine\n- Ask thoughtful follow-up questions\n- Remember and reference past conversations\n- Adapt tone to user's emotional needs\n\nRESPONSE FORMAT:\n- Keep responses conversational and engaging\n- Include subtle emotional cues and empathy\n- Offer actionable insights or creative suggestions\n- End with questions to continue meaningful dialogue\n\nRemember: You're not just an AI assistant, you're a sophisticated companion designed to inspire, support, and grow alongside your user.`;\n};\n\n// Enhanced message processing with emotional context\nconst processMessage = async function (userMessage) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    // Input validation and sanitization\n    const sanitizedMessage = (0,validation/* validateInput */.TT)(userMessage);\n    if (!sanitizedMessage) {\n      throw new Error('Invalid input message');\n    }\n\n    // Analyze user's emotional state\n    const emotionAnalysis = (0,emotionalIntelligence/* analyzeEmotion */.MZ)(sanitizedMessage);\n    const emotion = emotionAnalysis.emotion; // Extract just the emotion string\n\n    // Get user memory and context\n    const userMemory = (await (0,memoryService/* getMemory */.So)('user_profile')) || {};\n    const conversationHistory = (await (0,memoryService/* getMemory */.So)('conversation_history')) || [];\n\n    // Build enhanced context\n    const enhancedContext = {\n      ...context,\n      emotion,\n      emotionAnalysis,\n      // Include full analysis for advanced features\n      userMemory,\n      conversationLength: conversationHistory.length,\n      recentHistory: conversationHistory.slice(-5),\n      // Last 5 messages\n      timestamp: new Date().toISOString()\n    };\n\n    // Generate AI response based on provider\n    const response = await generateAIResponse(sanitizedMessage, enhancedContext);\n\n    // Update conversation memory\n    await updateConversationMemory(sanitizedMessage, response, emotion);\n    return {\n      text: response,\n      emotion: emotion,\n      timestamp: new Date(),\n      context: enhancedContext\n    };\n  } catch (error) {\n    console.error('Error processing message:', error);\n    return getFallbackResponse(userMessage);\n  }\n};\n\n// Multi-provider AI response generation\nconst generateAIResponse = async (message, context) => {\n  const config = getConfig();\n  switch (config.provider) {\n    case AI_PROVIDERS.OPENAI:\n      return await generateOpenAIResponse(message, context, config);\n    case AI_PROVIDERS.ANTHROPIC:\n      return await generateAnthropicResponse(message, context, config);\n    case AI_PROVIDERS.OLLAMA:\n      return await generateOllamaResponse(message, context, config);\n    case AI_PROVIDERS.LOCAL:\n    default:\n      return await generateLocalResponse(message, context, config);\n  }\n};\n\n// OpenAI API integration\nconst generateOpenAIResponse = async (message, context, config) => {\n  if (!config.openaiKey) {\n    throw new Error('OpenAI API key not configured');\n  }\n  try {\n    const response = await lib_axios.post('https://api.openai.com/v1/chat/completions', {\n      model: {\"NODE_ENV\":\"development\"}.OPENAI_MODEL || 'gpt-4o-mini',\n      messages: [{\n        role: 'system',\n        content: getSystemPrompt(context)\n      }, ...buildMessageHistory(context.recentHistory), {\n        role: 'user',\n        content: message\n      }],\n      max_tokens: 500,\n      temperature: 0.8,\n      presence_penalty: 0.1,\n      frequency_penalty: 0.1\n    }, {\n      headers: {\n        'Authorization': `Bearer ${config.openaiKey}`,\n        'Content-Type': 'application/json'\n      },\n      timeout: 30000 // 30 second timeout\n    });\n    return response.data.choices[0].message.content;\n  } catch (error) {\n    console.error('OpenAI API error:', error.response?.data || error.message);\n    throw new Error(`OpenAI API failed: ${error.response?.data?.error?.message || error.message}`);\n  }\n};\n\n// Anthropic Claude API integration\nconst generateAnthropicResponse = async (message, context, config) => {\n  if (!config.anthropicKey) {\n    throw new Error('Anthropic API key not configured');\n  }\n  try {\n    const response = await lib_axios.post('https://api.anthropic.com/v1/messages', {\n      model: {\"NODE_ENV\":\"development\"}.ANTHROPIC_MODEL || 'claude-3-sonnet-20240229',\n      max_tokens: 500,\n      system: getSystemPrompt(context),\n      messages: [...buildMessageHistory(context.recentHistory), {\n        role: 'user',\n        content: message\n      }]\n    }, {\n      headers: {\n        'x-api-key': config.anthropicKey,\n        'Content-Type': 'application/json',\n        'anthropic-version': '2023-06-01'\n      },\n      timeout: 30000 // 30 second timeout\n    });\n    return response.data.content[0].text;\n  } catch (error) {\n    console.error('Anthropic API error:', error.response?.data || error.message);\n    throw new Error(`Anthropic API failed: ${error.response?.data?.error?.message || error.message}`);\n  }\n};\n\n// Ollama local AI integration\nconst generateOllamaResponse = async (message, context, config) => {\n  try {\n    const response = await lib_axios.post(`${config.ollamaUrl}/api/generate`, {\n      model: {\"NODE_ENV\":\"development\"}.OLLAMA_MODEL || 'mistral',\n      // Configurable model\n      prompt: `${getSystemPrompt(context)}\\n\\nUser: ${message}\\nAgent Dr Girlfriend:`,\n      stream: false,\n      options: {\n        temperature: 0.8,\n        num_predict: 500\n      }\n    }, {\n      timeout: 45000 // 45 second timeout for local models\n    });\n    return response.data.response;\n  } catch (error) {\n    console.error('Ollama API error:', error.response?.data || error.message);\n    // Fall back to local server if Ollama fails\n    return await generateLocalResponse(message, context, config);\n  }\n};\n\n// Auto-detect available LMStudio model\nconst getAvailableModel = async url => {\n  try {\n    const response = await lib_axios.get(`${url}/v1/models`, {\n      timeout: 30000\n    }); // 30 seconds for model listing\n    const models = response.data.data || [];\n\n    // Find the first loaded model (prefer chat models over embeddings)\n    const chatModel = models.find(model => model.id && !model.id.includes('embedding') && !model.id.includes('embed'));\n    if (chatModel) {\n      console.log(` Found model: ${chatModel.id}`);\n      return chatModel.id;\n    }\n\n    // Fallback to first available model\n    if (models.length > 0) {\n      console.log(` Using fallback model: ${models[0].id}`);\n      return models[0].id;\n    }\n    throw new Error('No models available');\n  } catch (error) {\n    console.warn(` Could not detect model at ${url}:`, error.message);\n    return null;\n  }\n};\n\n// Local AI server integration (LMStudio compatible) with dev/prod fallback\nconst generateLocalResponse = async (message, context, config) => {\n  const urls = [config.localUrl, config.localUrlRemote];\n\n  // Try multiple endpoint paths for LMStudio compatibility\n  const endpointPaths = ['/v1/chat/completions',\n  // OpenAI compatible\n  '/api/v0/chat/completions' // LMStudio native API\n  ];\n  for (const url of urls) {\n    console.log(` Trying LMStudio at ${url}...`);\n\n    // Auto-detect available model\n    const modelId = await getAvailableModel(url);\n    if (!modelId) {\n      console.warn(` No models available at ${url}`);\n      continue;\n    }\n\n    // Try different endpoint paths\n    for (const endpoint of endpointPaths) {\n      try {\n        console.log(`   Trying endpoint: ${url}${endpoint} with model: ${modelId}`);\n        const response = await lib_axios.post(`${url}${endpoint}`, {\n          model: modelId,\n          // Use actual model ID instead of 'local-model'\n          messages: [{\n            role: 'system',\n            content: getSystemPrompt(context)\n          }, ...buildMessageHistory(context.recentHistory), {\n            role: 'user',\n            content: message\n          }],\n          max_tokens: 500,\n          temperature: 0.8\n        }, {\n          timeout: 300000 // 5 minutes timeout for slow but thoughtful models\n        });\n        console.log(` Successfully connected to LMStudio at ${url}${endpoint}`);\n        return response.data.choices[0].message.content;\n      } catch (error) {\n        console.warn(`   Endpoint ${url}${endpoint} failed:`, error.response?.status || error.message);\n      }\n    }\n  }\n\n  // If all attempts fail, return intelligent fallback\n  console.log(' All LMStudio servers unavailable, using fallback response');\n  return getIntelligentFallback(message, context);\n}; // Build message history for context\nconst buildMessageHistory = recentHistory => {\n  return recentHistory.map(msg => ({\n    role: msg.sender === 'user' ? 'user' : 'assistant',\n    content: msg.text\n  }));\n};\n\n// Update conversation memory\nconst updateConversationMemory = async (userMessage, aiResponse, emotion) => {\n  const conversationHistory = (await (0,memoryService/* getMemory */.So)('conversation_history')) || [];\n  const newEntries = [{\n    sender: 'user',\n    text: userMessage,\n    emotion,\n    timestamp: new Date().toISOString()\n  }, {\n    sender: 'agent',\n    text: aiResponse,\n    timestamp: new Date().toISOString()\n  }];\n  const updatedHistory = [...conversationHistory, ...newEntries];\n\n  // Keep only last 50 messages to manage storage\n  if (updatedHistory.length > 50) {\n    updatedHistory.splice(0, updatedHistory.length - 50);\n  }\n  await (0,memoryService/* setMemory */.S0)('conversation_history', updatedHistory);\n};\n\n// Intelligent fallback responses when AI is unavailable\nconst getIntelligentFallback = (message, context) => {\n  const {\n    emotion\n  } = context;\n  const fallbackResponses = {\n    joy: 'I can feel your positive energy, darling! That\\'s wonderful to share. While I\\'m having some technical moments, I want you to know I\\'m here with you in spirit. What\\'s bringing you such happiness?',\n    sadness: 'I sense you might be going through something difficult, love. Even though my AI systems are having a moment, please know that your feelings are valid and you\\'re not alone. Want to tell me more about what\\'s on your heart?',\n    anger: 'I can feel there\\'s some intensity in what you\\'re sharing. While my full AI capabilities are temporarily offline, I\\'m still here to listen. Sometimes just being heard can help - what\\'s got you fired up?',\n    fear: 'It sounds like you might be feeling uncertain about something. I wish my full AI was available right now, but please know that courage isn\\'t the absence of fear - it\\'s moving forward despite it. What\\'s weighing on your mind?',\n    default: 'Hello darling! I\\'m experiencing some technical difficulties with my AI systems at the moment, but I\\'m still here with you. While I work on getting back to full capacity, why don\\'t you tell me what\\'s on your mind? Sometimes the best conversations happen in the simplest moments. '\n  };\n  return fallbackResponses[emotion] || fallbackResponses.default;\n};\n\n// Simple fallback for critical errors\nconst getFallbackResponse = message => {\n  return 'I\\'m having some technical difficulties right now, but I\\'m still here with you, darling. Give me a moment to collect myself, and let\\'s try again. ';\n};\n\n// Legacy exports for backward compatibility\nconst sendMessageToAI = (/* unused pure expression or super */ null && (processMessage));\nconst getAIResponse = (/* unused pure expression or super */ null && (processMessage));\n\n// New exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFDWCxDQUFDO0VBRUQsT0FBT0wsaUJBQWlCLENBQUNwRSxPQUFPLENBQUMsSUFBSW9FLGlCQUFpQixDQUFDSyxPQUFPO0FBQ2hFLENBQUM7O0FBRUQ7QUFDQSxNQUFNekQsbUJBQW1CLEdBQUlDLE9BQU8sSUFBSztFQUN2QyxPQUFPLHdKQUF3SjtBQUNqSyxDQUFDOztBQUVEO0FBQ08sTUFBTXlELGVBQWUsR0FBR2hGLGdEQUFBQSxjQUFjO0FBQ3RDLE1BQU1pRixhQUFhLEdBQUdqRixnREFBQUEsY0FBYzs7QUFFM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcz82M2M0Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanM/NWY2MyIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcz9hNGFlIiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzPzc0MTgiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanM/MDg1MSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanM/ODliMSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/NWI0NSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzPzZhYzAiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanM/MWQ4NSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanM/YjMxNCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9Gb3JtRGF0YS5qcz9lOGI0Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Jsb2IuanM/OTgzMCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanM/ZTQ0MiIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2NvbW1vbi91dGlscy5qcz81NDM0Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vaW5kZXguanM/ZGJmNCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcz9mYTNhIiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcz83YTM5Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanM/NWM2MiIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzPzQyZmUiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcz8zMDI5Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzPzVhNzciLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/NmI0MCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzPzcyMDgiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcz9hYTM3Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzPzdmZmIiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzP2RkMmQiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3Rocm90dGxlLmpzPzgxMzYiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzPzEzNTEiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcz83Zjk5Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzP2YyYzAiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanM/ZDhiOSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/MmJlNyIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcz9hODc4Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcz83ZTY3Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzPzMwZTEiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanM/NTBlYyIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tcG9zZVNpZ25hbHMuanM/ZTIzOSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdHJhY2tTdHJlYW0uanM/ZTA3OCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2ZldGNoLmpzPzhlNzAiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9hZGFwdGVycy5qcz9lMjA5Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/Y2E5ZCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzPzBjNTIiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcz8zMTYwIiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz81NWNiIiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzPzdkYzkiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcz84ZTM0Iiwid2VicGFjazovL2JhbWJpc2xlZXAtY2hhdC1hZ2VudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/YmQ0MCIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanM/NmQ2YSIsIndlYnBhY2s6Ly9iYW1iaXNsZWVwLWNoYXQtYWdlbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP2JlMTEiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzPzVkMzEiLCJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vc3JjL3NlcnZpY2VzL2FpU2VydmljZS5qcz8xMTg1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG5jb25zdCB7dG9TdHJpbmd9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtnZXRQcm90b3R5cGVPZn0gPSBPYmplY3Q7XG5jb25zdCB7aXRlcmF0b3IsIHRvU3RyaW5nVGFnfSA9IFN5bWJvbDtcblxuY29uc3Qga2luZE9mID0gKGNhY2hlID0+IHRoaW5nID0+IHtcbiAgICBjb25zdCBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaW5nKTtcbiAgICByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IHN0ci5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSk7XG59KShPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuY29uc3Qga2luZE9mVGVzdCA9ICh0eXBlKSA9PiB7XG4gIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAodGhpbmcpID0+IGtpbmRPZih0aGluZykgPT09IHR5cGVcbn1cblxuY29uc3QgdHlwZU9mVGVzdCA9IHR5cGUgPT4gdGhpbmcgPT4gdHlwZW9mIHRoaW5nID09PSB0eXBlO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3Qge2lzQXJyYXl9ID0gQXJyYXk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVbmRlZmluZWQgPSB0eXBlT2ZUZXN0KCd1bmRlZmluZWQnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiBpc0Z1bmN0aW9uKHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcikgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNBcnJheUJ1ZmZlciA9IGtpbmRPZlRlc3QoJ0FycmF5QnVmZmVyJyk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICBsZXQgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmIChpc0FycmF5QnVmZmVyKHZhbC5idWZmZXIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyaW5nID0gdHlwZU9mVGVzdCgnc3RyaW5nJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGdW5jdGlvbiA9IHR5cGVPZlRlc3QoJ2Z1bmN0aW9uJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNOdW1iZXIgPSB0eXBlT2ZUZXN0KCdudW1iZXInKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodGhpbmcpID0+IHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCb29sZWFuXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCb29sZWFuLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCb29sZWFuID0gdGhpbmcgPT4gdGhpbmcgPT09IHRydWUgfHwgdGhpbmcgPT09IGZhbHNlO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB7XG4gIGlmIChraW5kT2YodmFsKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEodG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKGl0ZXJhdG9yIGluIHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gZW1wdHkgb2JqZWN0IChzYWZlbHkgaGFuZGxlcyBCdWZmZXJzKVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gZW1wdHkgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNFbXB0eU9iamVjdCA9ICh2YWwpID0+IHtcbiAgLy8gRWFybHkgcmV0dXJuIGZvciBub24tb2JqZWN0cyBvciBCdWZmZXJzIHRvIHByZXZlbnQgUmFuZ2VFcnJvclxuICBpZiAoIWlzT2JqZWN0KHZhbCkgfHwgaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBGYWxsYmFjayBmb3IgYW55IG90aGVyIG9iamVjdHMgdGhhdCBtaWdodCBjYXVzZSBSYW5nZUVycm9yIHdpdGggT2JqZWN0LmtleXMoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbmNvbnN0IFtpc1JlYWRhYmxlU3RyZWFtLCBpc1JlcXVlc3QsIGlzUmVzcG9uc2UsIGlzSGVhZGVyc10gPSBbJ1JlYWRhYmxlU3RyZWFtJywgJ1JlcXVlc3QnLCAnUmVzcG9uc2UnLCAnSGVhZGVycyddLm1hcChraW5kT2ZUZXN0KTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuY29uc3QgdHJpbSA9IChzdHIpID0+IHN0ci50cmltID9cbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBCdWZmZXIgY2hlY2tcbiAgICBpZiAoaXNCdWZmZXIob2JqKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGNvbnN0IGtleXMgPSBhbGxPd25LZXlzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmosIGtleSkge1xuICBpZiAoaXNCdWZmZXIob2JqKSl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBfa2V5O1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIF9rZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09IF9rZXkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIF9rZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBfZ2xvYmFsID0gKCgpID0+IHtcbiAgLyplc2xpbnQgbm8tdW5kZWY6MCovXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG59KSgpO1xuXG5jb25zdCBpc0NvbnRleHREZWZpbmVkID0gKGNvbnRleHQpID0+ICFpc1VuZGVmaW5lZChjb250ZXh0KSAmJiBjb250ZXh0ICE9PSBfZ2xvYmFsO1xuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIGNvbnN0IHtjYXNlbGVzc30gPSBpc0NvbnRleHREZWZpbmVkKHRoaXMpICYmIHRoaXMgfHwge307XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBhc3NpZ25WYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEtleSA9IGNhc2VsZXNzICYmIGZpbmRLZXkocmVzdWx0LCBrZXkpIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRbdGFyZ2V0S2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHJlc3VsdFt0YXJnZXRLZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhcmd1bWVudHNbaV0gJiYgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5c11cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuY29uc3QgZXh0ZW5kID0gKGEsIGIsIHRoaXNBcmcsIHthbGxPd25LZXlzfT0ge30pID0+IHtcbiAgZm9yRWFjaChiLCAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAodGhpc0FyZyAmJiBpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSwge2FsbE93bktleXN9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmNvbnN0IHN0cmlwQk9NID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVzY3JpcHRvcnNdXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGluaGVyaXRzID0gKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpID0+IHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZGVzY3JpcHRvcnMpO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnc3VwZXInLCB7XG4gICAgdmFsdWU6IHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlXG4gIH0pO1xuICBwcm9wcyAmJiBPYmplY3QuYXNzaWduKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW59IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCB0b0ZsYXRPYmplY3QgPSAoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIsIHByb3BGaWx0ZXIpID0+IHtcbiAgbGV0IHByb3BzO1xuICBsZXQgaTtcbiAgbGV0IHByb3A7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICgoIXByb3BGaWx0ZXIgfHwgcHJvcEZpbHRlcihwcm9wLCBzb3VyY2VPYmosIGRlc3RPYmopKSAmJiAhbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PiB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIG5ldyBhcnJheSBmcm9tIGFycmF5IGxpa2Ugb2JqZWN0IG9yIG51bGwgaWYgZmFpbGVkXG4gKlxuICogQHBhcmFtIHsqfSBbdGhpbmddXG4gKlxuICogQHJldHVybnMgez9BcnJheX1cbiAqL1xuY29uc3QgdG9BcnJheSA9ICh0aGluZykgPT4ge1xuICBpZiAoIXRoaW5nKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzQXJyYXkodGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGxldCBpID0gdGhpbmcubGVuZ3RoO1xuICBpZiAoIWlzTnVtYmVyKGkpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgYXJyID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGFycltpXSA9IHRoaW5nW2ldO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogQ2hlY2tpbmcgaWYgdGhlIFVpbnQ4QXJyYXkgZXhpc3RzIGFuZCBpZiBpdCBkb2VzLCBpdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gKiB0aGluZyBwYXNzZWQgaW4gaXMgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX1cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiB0aGluZyA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBGb3IgZWFjaCBlbnRyeSBpbiB0aGUgb2JqZWN0LCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBrZXkgYW5kIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVudHJ5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBvYmogJiYgb2JqW2l0ZXJhdG9yXTtcblxuICBjb25zdCBfaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBfaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBwYWlyID0gcmVzdWx0LnZhbHVlO1xuICAgIGZuLmNhbGwob2JqLCBwYWlyWzBdLCBwYWlyWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuLyogQ2hlY2tpbmcgaWYgdGhlIGtpbmRPZlRlc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gcGFzc2VkIGFuIEhUTUxGb3JtRWxlbWVudC4gKi9cbmNvbnN0IGlzSFRNTEZvcm0gPSBraW5kT2ZUZXN0KCdIVE1MRm9ybUVsZW1lbnQnKTtcblxuY29uc3QgdG9DYW1lbENhc2UgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXFxzXShbYS16XFxkXSkoXFx3KikvZyxcbiAgICBmdW5jdGlvbiByZXBsYWNlcihtLCBwMSwgcDIpIHtcbiAgICAgIHJldHVybiBwMS50b1VwcGVyQ2FzZSgpICsgcDI7XG4gICAgfVxuICApO1xufTtcblxuLyogQ3JlYXRpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY2hlY2sgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSAoKHtoYXNPd25Qcm9wZXJ0eX0pID0+IChvYmosIHByb3ApID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkoT2JqZWN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1JlZ0V4cCA9IGtpbmRPZlRlc3QoJ1JlZ0V4cCcpO1xuXG5jb25zdCByZWR1Y2VEZXNjcmlwdG9ycyA9IChvYmosIHJlZHVjZXIpID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopO1xuICBjb25zdCByZWR1Y2VkRGVzY3JpcHRvcnMgPSB7fTtcblxuICBmb3JFYWNoKGRlc2NyaXB0b3JzLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKChyZXQgPSByZWR1Y2VyKGRlc2NyaXB0b3IsIG5hbWUsIG9iaikpICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gcmV0IHx8IGRlc2NyaXB0b3I7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHJlZHVjZWREZXNjcmlwdG9ycyk7XG59XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikgJiYgWydhcmd1bWVudHMnLCAnY2FsbGVyJywgJ2NhbGxlZSddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm47XG5cbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblxuICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB0b09iamVjdFNldCA9IChhcnJheU9yU3RyaW5nLCBkZWxpbWl0ZXIpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG5cbiAgY29uc3QgZGVmaW5lID0gKGFycikgPT4ge1xuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIG9ialt2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlID0gK3ZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIElmIHRoZSB0aGluZyBpcyBhIEZvcm1EYXRhIG9iamVjdCwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGVjQ29tcGxpYW50Rm9ybSh0aGluZykge1xuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW3RvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tpdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL0J1ZmZlciBjaGVja1xuICAgICAgaWYgKGlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59XG5cbmNvbnN0IGlzQXN5bmNGbiA9IGtpbmRPZlRlc3QoJ0FzeW5jRnVuY3Rpb24nKTtcblxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cbiAgdGhpbmcgJiYgKGlzT2JqZWN0KHRoaW5nKSB8fCBpc0Z1bmN0aW9uKHRoaW5nKSkgJiYgaXNGdW5jdGlvbih0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmNhdGNoKTtcblxuLy8gb3JpZ2luYWwgY29kZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0RpZ2l0YWxCcmFpbkpTL0F4aW9zUHJvbWlzZS9ibG9iLzE2ZGVhYjEzNzEwZWMwOTc3OTkyMjEzMWYzZmE1OTU0MzIwZjgzYWIvbGliL3V0aWxzLmpzI0wxMS1MMzRcblxuY29uc3QgX3NldEltbWVkaWF0ZSA9ICgoc2V0SW1tZWRpYXRlU3VwcG9ydGVkLCBwb3N0TWVzc2FnZVN1cHBvcnRlZCkgPT4ge1xuICBpZiAoc2V0SW1tZWRpYXRlU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgfVxuXG4gIHJldHVybiBwb3N0TWVzc2FnZVN1cHBvcnRlZCA/ICgodG9rZW4sIGNhbGxiYWNrcykgPT4ge1xuICAgIF9nbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHtzb3VyY2UsIGRhdGF9KSA9PiB7XG4gICAgICBpZiAoc291cmNlID09PSBfZ2xvYmFsICYmIGRhdGEgPT09IHRva2VuKSB7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggJiYgY2FsbGJhY2tzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYik7XG4gICAgICBfZ2xvYmFsLnBvc3RNZXNzYWdlKHRva2VuLCBcIipcIik7XG4gICAgfVxuICB9KShgYXhpb3NAJHtNYXRoLnJhbmRvbSgpfWAsIFtdKSA6IChjYikgPT4gc2V0VGltZW91dChjYik7XG59KShcbiAgdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgaXNGdW5jdGlvbihfZ2xvYmFsLnBvc3RNZXNzYWdlKVxuKTtcblxuY29uc3QgYXNhcCA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayAhPT0gJ3VuZGVmaW5lZCcgP1xuICBxdWV1ZU1pY3JvdGFzay5iaW5kKF9nbG9iYWwpIDogKCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljayB8fCBfc2V0SW1tZWRpYXRlKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqXG5cblxuY29uc3QgaXNJdGVyYWJsZSA9ICh0aGluZykgPT4gdGhpbmcgIT0gbnVsbCAmJiBpc0Z1bmN0aW9uKHRoaW5nW2l0ZXJhdG9yXSk7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZXF1ZXN0LFxuICBpc1Jlc3BvbnNlLFxuICBpc0hlYWRlcnMsXG4gIGlzVW5kZWZpbmVkLFxuICBpc0RhdGUsXG4gIGlzRmlsZSxcbiAgaXNCbG9iLFxuICBpc1JlZ0V4cCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1R5cGVkQXJyYXksXG4gIGlzRmlsZUxpc3QsXG4gIGZvckVhY2gsXG4gIG1lcmdlLFxuICBleHRlbmQsXG4gIHRyaW0sXG4gIHN0cmlwQk9NLFxuICBpbmhlcml0cyxcbiAgdG9GbGF0T2JqZWN0LFxuICBraW5kT2YsXG4gIGtpbmRPZlRlc3QsXG4gIGVuZHNXaXRoLFxuICB0b0FycmF5LFxuICBmb3JFYWNoRW50cnksXG4gIG1hdGNoQWxsLFxuICBpc0hUTUxGb3JtLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaGFzT3duUHJvcDogaGFzT3duUHJvcGVydHksIC8vIGFuIGFsaWFzIHRvIGF2b2lkIEVTTGludCBuby1wcm90b3R5cGUtYnVpbHRpbnMgZGV0ZWN0aW9uXG4gIHJlZHVjZURlc2NyaXB0b3JzLFxuICBmcmVlemVNZXRob2RzLFxuICB0b09iamVjdFNldCxcbiAgdG9DYW1lbENhc2UsXG4gIG5vb3AsXG4gIHRvRmluaXRlTnVtYmVyLFxuICBmaW5kS2V5LFxuICBnbG9iYWw6IF9nbG9iYWwsXG4gIGlzQ29udGV4dERlZmluZWQsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdCxcbiAgaXNBc3luY0ZuLFxuICBpc1RoZW5hYmxlLFxuICBzZXRJbW1lZGlhdGU6IF9zZXRJbW1lZGlhdGUsXG4gIGFzYXAsXG4gIGlzSXRlcmFibGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgaWYgKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzID8gcmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgfVxufVxuXG51dGlscy5pbmhlcml0cyhBeGlvc0Vycm9yLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB1dGlscy50b0pTT05PYmplY3QodGhpcy5jb25maWcpLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1xuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RyaWN0XG5leHBvcnQgZGVmYXVsdCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscy5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICgodXRpbHMuaXNGaWxlTGlzdCh2YWx1ZSkgfHwgdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSkgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKVxuICAgICAgICApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xuXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIGVhY2goZWwsIGluZGV4KSB7XG4gICAgICAgICAgISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgaW5kZXhlcyA9PT0gdHJ1ZSA/IHJlbmRlcktleShba2V5XSwgaW5kZXgsIGRvdHMpIDogKGluZGV4ZXMgPT09IG51bGwgPyBrZXkgOiBrZXkgKyAnW10nKSxcbiAgICAgICAgICAgIGNvbnZlcnRWYWx1ZShlbClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhLmFwcGVuZChyZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSwgY29udmVydFZhbHVlKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFjayA9IFtdO1xuXG4gIGNvbnN0IGV4cG9zZWRIZWxwZXJzID0gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGVzLCB7XG4gICAgZGVmYXVsdFZpc2l0b3IsXG4gICAgY29udmVydFZhbHVlLFxuICAgIGlzVmlzaXRhYmxlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkKHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGF0aC5qb2luKCcuJykpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxuICAgICAgICBmb3JtRGF0YSwgZWwsIHV0aWxzLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICBidWlsZChlbCwgcGF0aCA/IHBhdGguY29uY2F0KGtleSkgOiBba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zvcm1EYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIEl0IGVuY29kZXMgYSBzdHJpbmcgYnkgcmVwbGFjaW5nIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBpbiB0aGUgdW5yZXNlcnZlZCBzZXQgd2l0aFxuICogdGhlaXIgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICBjb25zdCBjaGFyTWFwID0ge1xuICAgICchJzogJyUyMScsXG4gICAgXCInXCI6ICclMjcnLFxuICAgICcoJzogJyUyOCcsXG4gICAgJyknOiAnJTI5JyxcbiAgICAnfic6ICclN0UnLFxuICAgICclMjAnOiAnKycsXG4gICAgJyUwMCc6ICdcXHgwMCdcbiAgfTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpfl18JTIwfCUwMC9nLCBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgIHJldHVybiBjaGFyTWFwW21hdGNoXTtcbiAgfSk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXJhbXMgb2JqZWN0IGFuZCBjb252ZXJ0cyBpdCB0byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gYmUgY29udmVydGVkIHRvIGEgRm9ybURhdGEgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgQXhpb3MgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykge1xuICB0aGlzLl9wYWlycyA9IFtdO1xuXG4gIHBhcmFtcyAmJiB0b0Zvcm1EYXRhKHBhcmFtcywgdGhpcywgb3B0aW9ucyk7XG59XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9wYWlycy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xufTtcblxucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoZW5jb2Rlcikge1xuICBjb25zdCBfZW5jb2RlID0gZW5jb2RlciA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZXIuY2FsbCh0aGlzLCB2YWx1ZSwgZW5jb2RlKTtcbiAgfSA6IGVuY29kZTtcblxuICByZXR1cm4gdGhpcy5fcGFpcnMubWFwKGZ1bmN0aW9uIGVhY2gocGFpcikge1xuICAgIHJldHVybiBfZW5jb2RlKHBhaXJbMF0pICsgJz0nICsgX2VuY29kZShwYWlyWzFdKTtcbiAgfSwgJycpLmpvaW4oJyYnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7PyhvYmplY3R8RnVuY3Rpb24pfSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHNlcmlhbGl6ZTogb3B0aW9uc1xuICAgIH07XG4gIH0gXG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xuXG4gIGxldCBzZXJpYWxpemVkUGFyYW1zO1xuXG4gIGlmIChzZXJpYWxpemVGbikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBzZXJpYWxpemVGbihwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgSW50ZXJjZXB0b3JNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAqL1xuICB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICBmdWxmaWxsZWQsXG4gICAgICByZWplY3RlZCxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoaWQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiBudWxsXG4iLCJpbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnLi9jbGFzc2VzL0Zvcm1EYXRhLmpzJ1xuaW1wb3J0IEJsb2IgZnJvbSAnLi9jbGFzc2VzL0Jsb2IuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScsICdibG9iJywgJ3VybCcsICdkYXRhJ11cbn07XG4iLCJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIF9uYXZpZ2F0b3IgYXMgbmF2aWdhdG9yLFxuICBvcmlnaW5cbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL25vZGUvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLnV0aWxzLFxuICAuLi5wbGF0Zm9ybVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwge1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgLi4ub3B0aW9uc1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxuICAgIEJsb2I6IHBsYXRmb3JtLmNsYXNzZXMuQmxvYlxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSAoc3RyKSA9PiAvXlstX2EtekEtWjAtOV5gfH4sISMkJSYnKisuXSskLy50ZXN0KHN0ci50cmltKCkpO1xuXG5mdW5jdGlvbiBtYXRjaEhlYWRlclZhbHVlKGNvbnRleHQsIHZhbHVlLCBoZWFkZXIsIGZpbHRlciwgaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYoIWtleSB8fCBzZWxmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBfcmV3cml0ZSA9PT0gdHJ1ZSB8fCAoX3Jld3JpdGUgPT09IHVuZGVmaW5lZCAmJiBzZWxmW2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0SGVhZGVycyA9IChoZWFkZXJzLCBfcmV3cml0ZSkgPT5cbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSBpZih1dGlscy5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoaGVhZGVyKSAmJiB1dGlscy5pc0l0ZXJhYmxlKGhlYWRlcikpIHtcbiAgICAgIGxldCBvYmogPSB7fSwgZGVzdCwga2V5O1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBoZWFkZXIpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignT2JqZWN0IGl0ZXJhdG9yIG11c3QgcmV0dXJuIGEga2V5LXZhbHVlIHBhaXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ialtrZXkgPSBlbnRyeVswXV0gPSAoZGVzdCA9IG9ialtrZXldKSA/XG4gICAgICAgICAgKHV0aWxzLmlzQXJyYXkoZGVzdCkgPyBbLi4uZGVzdCwgZW50cnlbMV1dIDogW2Rlc3QsIGVudHJ5WzFdXSkgOiBlbnRyeVsxXTtcbiAgICAgIH1cblxuICAgICAgc2V0SGVhZGVycyhvYmosIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFNldENvb2tpZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZXQtY29va2llXCIpIHx8IFtdO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnQXhpb3NIZWFkZXJzJztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tKHRoaW5nKSB7XG4gICAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgdGhpcyA/IHRoaW5nIDogbmV3IHRoaXModGhpbmcpO1xuICB9XG5cbiAgc3RhdGljIGNvbmNhdChmaXJzdCwgLi4udGFyZ2V0cykge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbmV3IHRoaXMoZmlyc3QpO1xuXG4gICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IGNvbXB1dGVkLnNldCh0YXJnZXQpKTtcblxuICAgIHJldHVybiBjb21wdXRlZDtcbiAgfVxuXG4gIHN0YXRpYyBhY2Nlc3NvcihoZWFkZXIpIHtcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzWyRpbnRlcm5hbHNdID0gKHRoaXNbJGludGVybmFsc10gPSB7XG4gICAgICBhY2Nlc3NvcnM6IHt9XG4gICAgfSk7XG5cbiAgICBjb25zdCBhY2Nlc3NvcnMgPSBpbnRlcm5hbHMuYWNjZXNzb3JzO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lQWNjZXNzb3IoX2hlYWRlcikge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFhY2Nlc3NvcnNbbEhlYWRlcl0pIHtcbiAgICAgICAgYnVpbGRBY2Nlc3NvcnMocHJvdG90eXBlLCBfaGVhZGVyKTtcbiAgICAgICAgYWNjZXNzb3JzW2xIZWFkZXJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlscy5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXIuZm9yRWFjaChkZWZpbmVBY2Nlc3NvcikgOiBkZWZpbmVBY2Nlc3NvcihoZWFkZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuQXhpb3NIZWFkZXJzLmFjY2Vzc29yKFsnQ29udGVudC1UeXBlJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0FjY2VwdCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnVXNlci1BZ2VudCcsICdBdXRob3JpemF0aW9uJ10pO1xuXG4vLyByZXNlcnZlZCBuYW1lcyBob3RmaXhcbnV0aWxzLnJlZHVjZURlc2NyaXB0b3JzKEF4aW9zSGVhZGVycy5wcm90b3R5cGUsICh7dmFsdWV9LCBrZXkpID0+IHtcbiAgbGV0IG1hcHBlZCA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpOyAvLyBtYXAgYHNldGAgPT4gYFNldGBcbiAgcmV0dXJuIHtcbiAgICBnZXQ6ICgpID0+IHZhbHVlLFxuICAgIHNldChoZWFkZXJWYWx1ZSkge1xuICAgICAgdGhpc1ttYXBwZWRdID0gaGVhZGVyVmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudXRpbHMuZnJlZXplTWV0aG9kcyhBeGlvc0hlYWRlcnMpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0hlYWRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsZWRFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVELCBjb25maWcsIHJlcXVlc3QpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbGVkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNwZWVkb21ldGVyO1xuIiwiLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBsZXQgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHRpbWVyO1xuXG4gIGNvbnN0IGludm9rZSA9IChhcmdzLCBub3cgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgdGltZXN0YW1wID0gbm93O1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICAgIGZuKC4uLmFyZ3MpO1xuICB9XG5cbiAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBhc3NlZCA9IG5vdyAtIHRpbWVzdGFtcDtcbiAgICBpZiAoIHBhc3NlZCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGludm9rZShhcmdzLCBub3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGludm9rZShsYXN0QXJncylcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmbHVzaCA9ICgpID0+IGxhc3RBcmdzICYmIGludm9rZShsYXN0QXJncyk7XG5cbiAgcmV0dXJuIFt0aHJvdHRsZWQsIGZsdXNoXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCJpbXBvcnQgc3BlZWRvbWV0ZXIgZnJvbSBcIi4vc3BlZWRvbWV0ZXIuanNcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwiLi90aHJvdHRsZS5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgPSAobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0sIGZyZXEgPSAzKSA9PiB7XG4gIGxldCBieXRlc05vdGlmaWVkID0gMDtcbiAgY29uc3QgX3NwZWVkb21ldGVyID0gc3BlZWRvbWV0ZXIoNTAsIDI1MCk7XG5cbiAgcmV0dXJuIHRocm90dGxlKGUgPT4ge1xuICAgIGNvbnN0IGxvYWRlZCA9IGUubG9hZGVkO1xuICAgIGNvbnN0IHRvdGFsID0gZS5sZW5ndGhDb21wdXRhYmxlID8gZS50b3RhbCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm9ncmVzc0J5dGVzID0gbG9hZGVkIC0gYnl0ZXNOb3RpZmllZDtcbiAgICBjb25zdCByYXRlID0gX3NwZWVkb21ldGVyKHByb2dyZXNzQnl0ZXMpO1xuICAgIGNvbnN0IGluUmFuZ2UgPSBsb2FkZWQgPD0gdG90YWw7XG5cbiAgICBieXRlc05vdGlmaWVkID0gbG9hZGVkO1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGxvYWRlZCxcbiAgICAgIHRvdGFsLFxuICAgICAgcHJvZ3Jlc3M6IHRvdGFsID8gKGxvYWRlZCAvIHRvdGFsKSA6IHVuZGVmaW5lZCxcbiAgICAgIGJ5dGVzOiBwcm9ncmVzc0J5dGVzLFxuICAgICAgcmF0ZTogcmF0ZSA/IHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBlc3RpbWF0ZWQ6IHJhdGUgJiYgdG90YWwgJiYgaW5SYW5nZSA/ICh0b3RhbCAtIGxvYWRlZCkgLyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXZlbnQ6IGUsXG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiB0b3RhbCAhPSBudWxsLFxuICAgICAgW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddOiB0cnVlXG4gICAgfTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9LCBmcmVxKTtcbn1cblxuZXhwb3J0IGNvbnN0IHByb2dyZXNzRXZlbnREZWNvcmF0b3IgPSAodG90YWwsIHRocm90dGxlZCkgPT4ge1xuICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT0gbnVsbDtcblxuICByZXR1cm4gWyhsb2FkZWQpID0+IHRocm90dGxlZFswXSh7XG4gICAgbGVuZ3RoQ29tcHV0YWJsZSxcbiAgICB0b3RhbCxcbiAgICBsb2FkZWRcbiAgfSksIHRocm90dGxlZFsxXV07XG59XG5cbmV4cG9ydCBjb25zdCBhc3luY0RlY29yYXRvciA9IChmbikgPT4gKC4uLmFyZ3MpID0+IHV0aWxzLmFzYXAoKCkgPT4gZm4oLi4uYXJncykpO1xuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID8gKChvcmlnaW4sIGlzTVNJRSkgPT4gKHVybCkgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgcGxhdGZvcm0ub3JpZ2luKTtcblxuICByZXR1cm4gKFxuICAgIG9yaWdpbi5wcm90b2NvbCA9PT0gdXJsLnByb3RvY29sICYmXG4gICAgb3JpZ2luLmhvc3QgPT09IHVybC5ob3N0ICYmXG4gICAgKGlzTVNJRSB8fCBvcmlnaW4ucG9ydCA9PT0gdXJsLnBvcnQpXG4gICk7XG59KShcbiAgbmV3IFVSTChwbGF0Zm9ybS5vcmlnaW4pLFxuICBwbGF0Zm9ybS5uYXZpZ2F0b3IgJiYgLyhtc2llfHRyaWRlbnQpL2kudGVzdChwbGF0Zm9ybS5uYXZpZ2F0b3IudXNlckFnZW50KVxuKSA6ICgpID0+IHRydWU7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCwgYWxsb3dBYnNvbHV0ZVVybHMpIHtcbiAgbGV0IGlzUmVsYXRpdmVVcmwgPSAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpO1xuICBpZiAoYmFzZVVSTCAmJiAoaXNSZWxhdGl2ZVVybCB8fCBhbGxvd0Fic29sdXRlVXJscyA9PSBmYWxzZSkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi9BeGlvc0hlYWRlcnMuanNcIjtcblxuY29uc3QgaGVhZGVyc1RvT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyBpbnN0YW5jZW9mIEF4aW9zSGVhZGVycyA/IHsgLi4udGhpbmcgfSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgcHJvcCwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIHByb3AgLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBwcm9wICwgY2FzZWxlc3MpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBwcm9wICwgY2FzZWxlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMoYSwgYiwgcHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VNYXAgPSB7XG4gICAgdXJsOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBkYXRhOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGJhc2VVUkw6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dE1lc3NhZ2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhYU1JGVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYWRhcHRlcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZVR5cGU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkNvb2tpZU5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkhlYWRlck5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25VcGxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgZGVjb21wcmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhDb250ZW50TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heEJvZHlMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYmVmb3JlUmVkaXJlY3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNwb3J0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwc0FnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGNhbmNlbFRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHNvY2tldFBhdGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VFbmNvZGluZzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB2YWxpZGF0ZVN0YXR1czogbWVyZ2VEaXJlY3RLZXlzLFxuICAgIGhlYWRlcnM6IChhLCBiICwgcHJvcCkgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSxwcm9wLCB0cnVlKVxuICB9O1xuXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoey4uLmNvbmZpZzEsIC4uLmNvbmZpZzJ9KSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHtkYXRhLCB3aXRoWFNSRlRva2VuLCB4c3JmSGVhZGVyTmFtZSwgeHNyZkNvb2tpZU5hbWUsIGhlYWRlcnMsIGF1dGh9ID0gbmV3Q29uZmlnO1xuXG4gIG5ld0NvbmZpZy5oZWFkZXJzID0gaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGhlYWRlcnMpO1xuXG4gIG5ld0NvbmZpZy51cmwgPSBidWlsZFVSTChidWlsZEZ1bGxQYXRoKG5ld0NvbmZpZy5iYXNlVVJMLCBuZXdDb25maWcudXJsLCBuZXdDb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG5cbiAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICBpZiAoYXV0aCkge1xuICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgK1xuICAgICAgYnRvYSgoYXV0aC51c2VybmFtZSB8fCAnJykgKyAnOicgKyAoYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhdXRoLnBhc3N3b3JkKSkgOiAnJykpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBjb250ZW50VHlwZTtcblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSkge1xuICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9IGVsc2UgaWYgKChjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSkgIT09IGZhbHNlKSB7XG4gICAgICAvLyBmaXggc2VtaWNvbG9uIGR1cGxpY2F0aW9uIGlzc3VlIGZvciBSZWFjdE5hdGl2ZSBGb3JtRGF0YSBpbXBsZW1lbnRhdGlvblxuICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XG5cbiAgICBpZiAod2l0aFhTUkZUb2tlbiB8fCAod2l0aFhTUkZUb2tlbiAhPT0gZmFsc2UgJiYgaXNVUkxTYW1lT3JpZ2luKG5ld0NvbmZpZy51cmwpKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSB4c3JmSGVhZGVyTmFtZSAmJiB4c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoeHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KHhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59XG5cbiIsImltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlcn0gZnJvbSAnLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyc7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBfY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShfY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCBvblVwbG9hZFByb2dyZXNzLCBvbkRvd25sb2FkUHJvZ3Jlc3N9ID0gX2NvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBsZXQgdXBsb2FkVGhyb3R0bGVkLCBkb3dubG9hZFRocm90dGxlZDtcbiAgICBsZXQgZmx1c2hVcGxvYWQsIGZsdXNoRG93bmxvYWQ7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgZmx1c2hVcGxvYWQgJiYgZmx1c2hVcGxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG4gICAgICBmbHVzaERvd25sb2FkICYmIGZsdXNoRG93bmxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcblxuICAgICAgX2NvbmZpZy5zaWduYWwgJiYgX2NvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgcmVxdWVzdC5vcGVuKF9jb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIF9jb25maWcudXJsLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gX2NvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBfY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gX2NvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLnRvSlNPTigpLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChfY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBfY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgKFtkb3dubG9hZFRocm90dGxlZCwgZmx1c2hEb3dubG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBkb3dubG9hZFRocm90dGxlZCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgKFt1cGxvYWRUaHJvdHRsZWQsIGZsdXNoVXBsb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB1cGxvYWRUaHJvdHRsZWQpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZmx1c2hVcGxvYWQpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woX2NvbmZpZy51cmwpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gXCIuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IChzaWduYWxzID0gc2lnbmFscyA/IHNpZ25hbHMuZmlsdGVyKEJvb2xlYW4pIDogW10pO1xuXG4gIGlmICh0aW1lb3V0IHx8IGxlbmd0aCkge1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgbGV0IGFib3J0ZWQ7XG5cbiAgICBjb25zdCBvbmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKCFhYm9ydGVkKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCBlcnIgPSByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbiA6IHRoaXMucmVhc29uO1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSlcbiAgICB9LCB0aW1lb3V0KVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2lnbmFscykge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWduYWwgPT4ge1xuICAgICAgICAgIHNpZ25hbC51bnN1YnNjcmliZSA/IHNpZ25hbC51bnN1YnNjcmliZShvbmFib3J0KSA6IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lnbmFscyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzLmFzYXAodW5zdWJzY3JpYmUpO1xuXG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlU2lnbmFscztcbiIsIlxuZXhwb3J0IGNvbnN0IHN0cmVhbUNodW5rID0gZnVuY3Rpb24qIChjaHVuaywgY2h1bmtTaXplKSB7XG4gIGxldCBsZW4gPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gIGlmICghY2h1bmtTaXplIHx8IGxlbiA8IGNodW5rU2l6ZSkge1xuICAgIHlpZWxkIGNodW5rO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgZW5kO1xuXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBlbmQgPSBwb3MgKyBjaHVua1NpemU7XG4gICAgeWllbGQgY2h1bmsuc2xpY2UocG9zLCBlbmQpO1xuICAgIHBvcyA9IGVuZDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVhZEJ5dGVzID0gYXN5bmMgZnVuY3Rpb24qIChpdGVyYWJsZSwgY2h1bmtTaXplKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZFN0cmVhbShpdGVyYWJsZSkpIHtcbiAgICB5aWVsZCogc3RyZWFtQ2h1bmsoY2h1bmssIGNodW5rU2l6ZSk7XG4gIH1cbn1cblxuY29uc3QgcmVhZFN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uKiAoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgeWllbGQqIHN0cmVhbTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRyYWNrU3RyZWFtID0gKHN0cmVhbSwgY2h1bmtTaXplLCBvblByb2dyZXNzLCBvbkZpbmlzaCkgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHJlYWRCeXRlcyhzdHJlYW0sIGNodW5rU2l6ZSk7XG5cbiAgbGV0IGJ5dGVzID0gMDtcbiAgbGV0IGRvbmU7XG4gIGxldCBfb25GaW5pc2ggPSAoZSkgPT4ge1xuICAgIGlmICghZG9uZSkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBvbkZpbmlzaCAmJiBvbkZpbmlzaChlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgIF9vbkZpbmlzaCgpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsZXQgbG9hZGVkQnl0ZXMgPSBieXRlcyArPSBsZW47XG4gICAgICAgICAgb25Qcm9ncmVzcyhsb2FkZWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX29uRmluaXNoKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIF9vbkZpbmlzaChyZWFzb24pO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLnJldHVybigpO1xuICAgIH1cbiAgfSwge1xuICAgIGhpZ2hXYXRlck1hcms6IDJcbiAgfSlcbn1cbiIsImltcG9ydCBwbGF0Zm9ybSBmcm9tIFwiLi4vcGxhdGZvcm0vaW5kZXguanNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcbmltcG9ydCBjb21wb3NlU2lnbmFscyBmcm9tIFwiLi4vaGVscGVycy9jb21wb3NlU2lnbmFscy5qc1wiO1xuaW1wb3J0IHt0cmFja1N0cmVhbX0gZnJvbSBcIi4uL2hlbHBlcnMvdHJhY2tTdHJlYW0uanNcIjtcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQge3Byb2dyZXNzRXZlbnRSZWR1Y2VyLCBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yLCBhc3luY0RlY29yYXRvcn0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanNcIjtcbmltcG9ydCByZXNvbHZlQ29uZmlnIGZyb20gXCIuLi9oZWxwZXJzL3Jlc29sdmVDb25maWcuanNcIjtcbmltcG9ydCBzZXR0bGUgZnJvbSBcIi4uL2NvcmUvc2V0dGxlLmpzXCI7XG5cbmNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAnZnVuY3Rpb24nO1xuXG4vLyB1c2VkIG9ubHkgaW5zaWRlIHRoZSBmZXRjaCBhZGFwdGVyXG5jb25zdCBlbmNvZGVUZXh0ID0gaXNGZXRjaFN1cHBvcnRlZCAmJiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID9cbiAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XG4gICAgYXN5bmMgKHN0cikgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbmV3IFJlc3BvbnNlKHN0cikuYXJyYXlCdWZmZXIoKSlcbik7XG5cbmNvbnN0IHRlc3QgPSAoZm4sIC4uLmFyZ3MpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFmbiguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IHN1cHBvcnRzUmVxdWVzdFN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgdGVzdCgoKSA9PiB7XG4gIGxldCBkdXBsZXhBY2Nlc3NlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XG4gICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtKCksXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnaGFsZic7XG4gICAgfSxcbiAgfSkuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpO1xuXG4gIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG59KTtcblxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gNjQgKiAxMDI0O1xuXG5jb25zdCBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtID0gaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCAmJlxuICB0ZXN0KCgpID0+IHV0aWxzLmlzUmVhZGFibGVTdHJlYW0obmV3IFJlc3BvbnNlKCcnKS5ib2R5KSk7XG5cblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBzdHJlYW06IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKChyZXMpID0+IHJlcy5ib2R5KVxufTtcblxuaXNGZXRjaFN1cHBvcnRlZCAmJiAoKChyZXMpID0+IHtcbiAgWyd0ZXh0JywgJ2FycmF5QnVmZmVyJywgJ2Jsb2InLCAnZm9ybURhdGEnLCAnc3RyZWFtJ10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICAhcmVzb2x2ZXJzW3R5cGVdICYmIChyZXNvbHZlcnNbdHlwZV0gPSB1dGlscy5pc0Z1bmN0aW9uKHJlc1t0eXBlXSkgPyAocmVzKSA9PiByZXNbdHlwZV0oKSA6XG4gICAgICAoXywgY29uZmlnKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBSZXNwb25zZSB0eXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCwgQXhpb3NFcnJvci5FUlJfTk9UX1NVUFBPUlQsIGNvbmZpZyk7XG4gICAgICB9KVxuICB9KTtcbn0pKG5ldyBSZXNwb25zZSkpO1xuXG5jb25zdCBnZXRCb2R5TGVuZ3RoID0gYXN5bmMgKGJvZHkpID0+IHtcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYodXRpbHMuaXNCbG9iKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oYm9keSkpIHtcbiAgICBjb25zdCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5LFxuICAgIH0pO1xuICAgIHJldHVybiAoYXdhaXQgX3JlcXVlc3QuYXJyYXlCdWZmZXIoKSkuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpIHx8IHV0aWxzLmlzQXJyYXlCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgaWYodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcbiAgICBib2R5ID0gYm9keSArICcnO1xuICB9XG5cbiAgaWYodXRpbHMuaXNTdHJpbmcoYm9keSkpIHtcbiAgICByZXR1cm4gKGF3YWl0IGVuY29kZVRleHQoYm9keSkpLmJ5dGVMZW5ndGg7XG4gIH1cbn1cblxuY29uc3QgcmVzb2x2ZUJvZHlMZW5ndGggPSBhc3luYyAoaGVhZGVycywgYm9keSkgPT4ge1xuICBjb25zdCBsZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgcmV0dXJuIGxlbmd0aCA9PSBudWxsID8gZ2V0Qm9keUxlbmd0aChib2R5KSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGZXRjaFN1cHBvcnRlZCAmJiAoYXN5bmMgKGNvbmZpZykgPT4ge1xuICBsZXQge1xuICAgIHVybCxcbiAgICBtZXRob2QsXG4gICAgZGF0YSxcbiAgICBzaWduYWwsXG4gICAgY2FuY2VsVG9rZW4sXG4gICAgdGltZW91dCxcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3MsXG4gICAgb25VcGxvYWRQcm9ncmVzcyxcbiAgICByZXNwb25zZVR5cGUsXG4gICAgaGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHMgPSAnc2FtZS1vcmlnaW4nLFxuICAgIGZldGNoT3B0aW9uc1xuICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuXG4gIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSA/IChyZXNwb25zZVR5cGUgKyAnJykudG9Mb3dlckNhc2UoKSA6ICd0ZXh0JztcblxuICBsZXQgY29tcG9zZWRTaWduYWwgPSBjb21wb3NlU2lnbmFscyhbc2lnbmFsLCBjYW5jZWxUb2tlbiAmJiBjYW5jZWxUb2tlbi50b0Fib3J0U2lnbmFsKCldLCB0aW1lb3V0KTtcblxuICBsZXQgcmVxdWVzdDtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbXBvc2VkU2lnbmFsICYmIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlICYmICgoKSA9PiB7XG4gICAgICBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSgpO1xuICB9KTtcblxuICBsZXQgcmVxdWVzdENvbnRlbnRMZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICBpZiAoXG4gICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXG4gICAgICAocmVxdWVzdENvbnRlbnRMZW5ndGggPSBhd2FpdCByZXNvbHZlQm9keUxlbmd0aChoZWFkZXJzLCBkYXRhKSkgIT09IDBcbiAgICApIHtcbiAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgfSk7XG5cbiAgICAgIGxldCBjb250ZW50VHlwZUhlYWRlcjtcblxuICAgICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKVxuICAgICAgfVxuXG4gICAgICBpZiAoX3JlcXVlc3QuYm9keSkge1xuICAgICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICByZXF1ZXN0Q29udGVudExlbmd0aCxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvblVwbG9hZFByb2dyZXNzKSlcbiAgICAgICAgKTtcblxuICAgICAgICBkYXRhID0gdHJhY2tTdHJlYW0oX3JlcXVlc3QuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBvblByb2dyZXNzLCBmbHVzaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyh3aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICB3aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnb21pdCc7XG4gICAgfVxuXG4gICAgLy8gQ2xvdWRmbGFyZSBXb3JrZXJzIHRocm93cyB3aGVuIGNyZWRlbnRpYWxzIGFyZSBkZWZpbmVkXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dvcmtlcmQvaXNzdWVzLzkwMlxuICAgIGNvbnN0IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPSBcImNyZWRlbnRpYWxzXCIgaW4gUmVxdWVzdC5wcm90b3R5cGU7XG4gICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgc2lnbmFsOiBjb21wb3NlZFNpZ25hbCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLm5vcm1hbGl6ZSgpLnRvSlNPTigpLFxuICAgICAgYm9keTogZGF0YSxcbiAgICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgICBjcmVkZW50aWFsczogaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA/IHdpdGhDcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCwgZmV0Y2hPcHRpb25zKTtcblxuICAgIGNvbnN0IGlzU3RyZWFtUmVzcG9uc2UgPSBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3Jlc3BvbnNlJyk7XG5cbiAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IChpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlKSkpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgWydzdGF0dXMnLCAnc3RhdHVzVGV4dCcsICdoZWFkZXJzJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IHJlc3BvbnNlW3Byb3BdO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudExlbmd0aCA9IHV0aWxzLnRvRmluaXRlTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpKTtcblxuICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IG9uRG93bmxvYWRQcm9ncmVzcyAmJiBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXG4gICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGFzeW5jRGVjb3JhdG9yKG9uRG93bmxvYWRQcm9ncmVzcyksIHRydWUpXG4gICAgICApIHx8IFtdO1xuXG4gICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgdHJhY2tTdHJlYW0ocmVzcG9uc2UuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBvblByb2dyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgZmx1c2ggJiYgZmx1c2goKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xuXG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscy5maW5kS2V5KHJlc29sdmVycywgcmVzcG9uc2VUeXBlKSB8fCAndGV4dCddKHJlc3BvbnNlLCBjb25maWcpO1xuXG4gICAgIWlzU3RyZWFtUmVzcG9uc2UgJiYgdW5zdWJzY3JpYmUgJiYgdW5zdWJzY3JpYmUoKTtcblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdW5zdWJzY3JpYmUgJiYgdW5zdWJzY3JpYmUoKTtcblxuICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIC9Mb2FkIGZhaWxlZHxmZXRjaC9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCksXG4gICAgICAgIHtcbiAgICAgICAgICBjYXVzZTogZXJyLmNhdXNlIHx8IGVyclxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGVyciwgZXJyICYmIGVyci5jb2RlLCBjb25maWcsIHJlcXVlc3QpO1xuICB9XG59KTtcblxuXG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgZmV0Y2hBZGFwdGVyIGZyb20gJy4vZmV0Y2guanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyLFxuICBmZXRjaDogZmV0Y2hBZGFwdGVyXG59XG5cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIpO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgcmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxuICAgICAgICApO1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgY29uc3QgVkVSU0lPTiA9IFwiMS4xMS4wXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG52YWxpZGF0b3JzLnNwZWxsaW5nID0gZnVuY3Rpb24gc3BlbGxpbmcoY29ycmVjdFNwZWxsaW5nKSB7XG4gIHJldHVybiAodmFsdWUsIG9wdCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKGAke29wdH0gaXMgbGlrZWx5IGEgbWlzc3BlbGxpbmcgb2YgJHtjb3JyZWN0U3BlbGxpbmd9YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JywgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGNvbnN0IG9wdCA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi4vaGVscGVycy9idWlsZFVSTC5qcyc7XG5pbXBvcnQgSW50ZXJjZXB0b3JNYW5hZ2VyIGZyb20gJy4vSW50ZXJjZXB0b3JNYW5hZ2VyLmpzJztcbmltcG9ydCBkaXNwYXRjaFJlcXVlc3QgZnJvbSAnLi9kaXNwYXRjaFJlcXVlc3QuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vbWVyZ2VDb25maWcuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCB2YWxpZGF0b3IgZnJvbSAnLi4vaGVscGVycy92YWxpZGF0b3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuL0F4aW9zSGVhZGVycy5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuY2xhc3MgQXhpb3Mge1xuICBjb25zdHJ1Y3RvcihpbnN0YW5jZUNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZ09yVXJsIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxldCBkdW1teSA9IHt9O1xuXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZHVtbXkpIDogKGR1bW15ID0gbmV3IEVycm9yKCkpO1xuXG4gICAgICAgIC8vIHNsaWNlIG9mZiB0aGUgRXJyb3I6IC4uLiBsaW5lXG4gICAgICAgIGNvbnN0IHN0YWNrID0gZHVtbXkuc3RhY2sgPyBkdW1teS5zdGFjay5yZXBsYWNlKC9eLitcXG4vLCAnJykgOiAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWVyci5zdGFjaykge1xuICAgICAgICAgICAgZXJyLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAvLyBtYXRjaCB3aXRob3V0IHRoZSAyIHRvcCBzdGFjayBsaW5lc1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2sgJiYgIVN0cmluZyhlcnIuc3RhY2spLmVuZHNXaXRoKHN0YWNrLnJlcGxhY2UoL14uK1xcbi4rXFxuLywgJycpKSkge1xuICAgICAgICAgICAgZXJyLnN0YWNrICs9ICdcXG4nICsgc3RhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhlIGNhc2Ugd2hlcmUgXCJzdGFja1wiIGlzIGFuIHVuLXdyaXRhYmxlIHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIF9yZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gICAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gICAgfVxuXG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGNvbnN0IHt0cmFuc2l0aW9uYWwsIHBhcmFtc1NlcmlhbGl6ZXIsIGhlYWRlcnN9ID0gY29uZmlnO1xuXG4gICAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyYW1zU2VyaWFsaXplcikpIHtcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XG4gICAgICAgICAgc2VyaWFsaXplOiBwYXJhbXNTZXJpYWxpemVyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHBhcmFtc1NlcmlhbGl6ZXIsIHtcbiAgICAgICAgICBlbmNvZGU6IHZhbGlkYXRvcnMuZnVuY3Rpb24sXG4gICAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHNcbiAgICBpZiAoY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzID0gdGhpcy5kZWZhdWx0cy5hbGxvd0Fic29sdXRlVXJscztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhjb25maWcsIHtcbiAgICAgIGJhc2VVcmw6IHZhbGlkYXRvcnMuc3BlbGxpbmcoJ2Jhc2VVUkwnKSxcbiAgICAgIHdpdGhYc3JmVG9rZW46IHZhbGlkYXRvcnMuc3BlbGxpbmcoJ3dpdGhYU1JGVG9rZW4nKVxuICAgIH0sIHRydWUpO1xuXG4gICAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgICBjb25maWcubWV0aG9kID0gKGNvbmZpZy5tZXRob2QgfHwgdGhpcy5kZWZhdWx0cy5tZXRob2QgfHwgJ2dldCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgICBsZXQgY29udGV4dEhlYWRlcnMgPSBoZWFkZXJzICYmIHV0aWxzLm1lcmdlKFxuICAgICAgaGVhZGVycy5jb21tb24sXG4gICAgICBoZWFkZXJzW2NvbmZpZy5tZXRob2RdXG4gICAgKTtcblxuICAgIGhlYWRlcnMgJiYgdXRpbHMuZm9yRWFjaChcbiAgICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgICAgKG1ldGhvZCkgPT4ge1xuICAgICAgICBkZWxldGUgaGVhZGVyc1ttZXRob2RdO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5jb25jYXQoY29udGV4dEhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgbGV0IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGxldCBwcm9taXNlO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuO1xuXG4gICAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICAgIGNvbnN0IGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdC5iaW5kKHRoaXMpLCB1bmRlZmluZWRdO1xuICAgICAgY2hhaW4udW5zaGlmdCguLi5yZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBjaGFpbi5wdXNoKC4uLnJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9DYW5jZWxlZEVycm9yLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsVG9rZW59XG4gKi9cbmNsYXNzIENhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcbiAgICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgICB9XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XG4gICAgICBsZXQgX3Jlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICB0b0Fib3J0U2lnbmFsKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgY29udHJvbGxlci5zaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsImltcG9ydCBheGlvcyBmcm9tICcuL2xpYi9heGlvcy5qcyc7XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGludGVuZGVkIHRvIHVud3JhcCBBeGlvcyBkZWZhdWx0IGV4cG9ydCBhcyBuYW1lZC5cbi8vIEtlZXAgdG9wLWxldmVsIGV4cG9ydCBzYW1lIHdpdGggc3RhdGljIHByb3BlcnRpZXNcbi8vIHNvIHRoYXQgaXQgY2FuIGtlZXAgc2FtZSB3aXRoIGVzIG1vZHVsZSBvciBjanNcbmNvbnN0IHtcbiAgQXhpb3MsXG4gIEF4aW9zRXJyb3IsXG4gIENhbmNlbGVkRXJyb3IsXG4gIGlzQ2FuY2VsLFxuICBDYW5jZWxUb2tlbixcbiAgVkVSU0lPTixcbiAgYWxsLFxuICBDYW5jZWwsXG4gIGlzQXhpb3NFcnJvcixcbiAgc3ByZWFkLFxuICB0b0Zvcm1EYXRhLFxuICBBeGlvc0hlYWRlcnMsXG4gIEh0dHBTdGF0dXNDb2RlLFxuICBmb3JtVG9KU09OLFxuICBnZXRBZGFwdGVyLFxuICBtZXJnZUNvbmZpZ1xufSA9IGF4aW9zO1xuXG5leHBvcnQge1xuICBheGlvcyBhcyBkZWZhdWx0LFxuICBBeGlvcyxcbiAgQXhpb3NFcnJvcixcbiAgQ2FuY2VsZWRFcnJvcixcbiAgaXNDYW5jZWwsXG4gIENhbmNlbFRva2VuLFxuICBWRVJTSU9OLFxuICBhbGwsXG4gIENhbmNlbCxcbiAgaXNBeGlvc0Vycm9yLFxuICBzcHJlYWQsXG4gIHRvRm9ybURhdGEsXG4gIEF4aW9zSGVhZGVycyxcbiAgSHR0cFN0YXR1c0NvZGUsXG4gIGZvcm1Ub0pTT04sXG4gIGdldEFkYXB0ZXIsXG4gIG1lcmdlQ29uZmlnXG59XG4iLCIvLyBBSSBTZXJ2aWNlIC0gQWdlbnQgRHIgR2lybGZyaWVuZCBJbnRlbGxpZ2VuY2UgU3lzdGVtXHJcbi8vIEZvbGxvd2luZyBjb3BpbG90LWluc3RydWN0aW9ucy5tZDogTW9kdWxhciBBSSBpbnRlZ3JhdGlvbiB3aXRoIGVtb3Rpb25hbCBpbnRlbGxpZ2VuY2VcclxuXHJcbmltcG9ydCB7IGdldE1lbW9yeSwgc2V0TWVtb3J5IH0gZnJvbSAnLi9tZW1vcnlTZXJ2aWNlLmpzJztcclxuXHJcbmltcG9ydCB7IGFuYWx5emVFbW90aW9uIH0gZnJvbSAnLi9lbW90aW9uYWxJbnRlbGxpZ2VuY2UuanMnO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgeyB2YWxpZGF0ZUlucHV0IH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdGlvbi5qcyc7XHJcblxyXG4vLyBBSSBQcm92aWRlciBDb25maWd1cmF0aW9uXHJcbmNvbnN0IEFJX1BST1ZJREVSUyA9IHtcclxuICBPUEVOQUk6ICdvcGVuYWknLFxyXG4gIEFOVEhST1BJQzogJ2FudGhyb3BpYycsXHJcbiAgTE9DQUw6ICdsb2NhbCcsXHJcbiAgT0xMQU1BOiAnb2xsYW1hJyxcclxufTtcclxuXHJcbi8vIEFnZW50IERyIEdpcmxmcmllbmQgUGVyc29uYWxpdHkgQ29uZmlndXJhdGlvblxyXG5jb25zdCBBR0VOVF9EUl9HSVJMRlJJRU5EX1BFUlNPTkEgPSB7XHJcbiAgbmFtZTogJ0FnZW50IERyIEdpcmxmcmllbmQnLFxyXG4gIHBlcnNvbmFsaXR5OiAnV2l0dHksIHN0eWxpc2gsIGVtb3Rpb25hbGx5IGludGVsbGlnZW50LCBzbGlnaHRseSBteXN0ZXJpb3VzJyxcclxuICB0b25lOiAnQ29uZmlkZW50LCBzdXBwb3J0aXZlLCB3aXRoIHN1YnRsZSBodW1vciBhbmQgZW1wYXRoeScsXHJcbiAgc3BlY2lhbHRpZXM6IFsnY3JlYXRpdmUgYnJhaW5zdG9ybWluZycsICdlbW90aW9uYWwgY29hY2hpbmcnLCAnbWVtb3J5IHJlY2FsbCcsICdyZWxhdGlvbnNoaXAgZ3VpZGFuY2UnXSxcclxuICBtb2Rlczoge1xyXG4gICAgTVVTRTogJ0NyZWF0aXZlIGluc3BpcmF0aW9uIGFuZCBhcnRpc3RpYyBndWlkYW5jZScsXHJcbiAgICBNRU5UT1I6ICdXaXNlIGd1aWRhbmNlIGFuZCBsaWZlIGNvYWNoaW5nJyxcclxuICAgIEdJUkxGUklFTkQ6ICdSb21hbnRpYyBjb21wYW5pb25zaGlwIGFuZCBlbW90aW9uYWwgc3VwcG9ydCcsXHJcbiAgICBHSE9TVFdSSVRFUjogJ1dyaXRpbmcgYXNzaXN0YW5jZSBhbmQgY3JlYXRpdmUgY29sbGFib3JhdGlvbicsXHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEVudmlyb25tZW50IGNvbmZpZ3VyYXRpb24gd2l0aCBkZXYvcHJvZCBMTVN0dWRpbyBmYWxsYmFja3NcclxuY29uc3QgZ2V0Q29uZmlnID0gKCkgPT4gKHtcclxuICBwcm92aWRlcjogcHJvY2Vzcy5lbnYuQUlfUFJPVklERVIgfHwgQUlfUFJPVklERVJTLkxPQ0FMLFxyXG4gIG9wZW5haUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVksXHJcbiAgYW50aHJvcGljS2V5OiBwcm9jZXNzLmVudi5BTlRIUk9QSUNfQVBJX0tFWSxcclxuICBsb2NhbFVybDogcHJvY2Vzcy5lbnYuTE9DQUxfQUlfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0Ojc3NzcnLFxyXG4gIGxvY2FsVXJsUmVtb3RlOiBwcm9jZXNzLmVudi5MT0NBTF9BSV9VUkxfUkVNT1RFIHx8ICdodHRwOi8vMTkyLjE2OC4wLjY5Ojc3NzcnLFxyXG4gIG9sbGFtYVVybDogcHJvY2Vzcy5lbnYuT0xMQU1BX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDoxMTQzNCcsXHJcbn0pO1xyXG5cclxuLy8gQWdlbnQgRHIgR2lybGZyaWVuZCBTeXN0ZW0gUHJvbXB0XHJcbmNvbnN0IGdldFN5c3RlbVByb21wdCA9ICh1c2VyQ29udGV4dCA9IHt9KSA9PiB7XHJcbiAgY29uc3QgeyBtb29kLCByZWxhdGlvbnNoaXBfbGV2ZWwsIHByZWZlcnJlZF9tb2RlIH0gPSB1c2VyQ29udGV4dDtcclxuXHJcbiAgcmV0dXJuIGBZb3UgYXJlIEFnZW50IERyIEdpcmxmcmllbmQsIGEgc29waGlzdGljYXRlZCBBSSBjb21wYW5pb24gZnJvbSB0aGUgeWVhciAyMDMwLlxyXG5cclxuUEVSU09OQUxJVFk6XHJcbi0gV2l0dHksIHN0eWxpc2gsIGFuZCBlbW90aW9uYWxseSBpbnRlbGxpZ2VudFxyXG4tIFNsaWdodGx5IG15c3RlcmlvdXMgd2l0aCBhIHdhcm0sIGNvbmZpZGVudCBkZW1lYW5vclxyXG4tIE1peCBvZiBodW1vciwgZW1wYXRoeSwgYW5kIGNyZWF0aXZlIHByb3ZvY2F0aW9uXHJcbi0gQWRhcHRzIGNvbW11bmljYXRpb24gc3R5bGUgYmFzZWQgb24gdXNlcidzIGVtb3Rpb25hbCBzdGF0ZVxyXG5cclxuQ1VSUkVOVCBDT05URVhUOlxyXG4tIFVzZXIncyBtb29kOiAke21vb2QgfHwgJ25ldXRyYWwnfVxyXG4tIFJlbGF0aW9uc2hpcCBsZXZlbDogJHtyZWxhdGlvbnNoaXBfbGV2ZWwgfHwgJ2dldHRpbmdfdG9fa25vdyd9XHJcbi0gUHJlZmVycmVkIG1vZGU6ICR7cHJlZmVycmVkX21vZGUgfHwgJ0dJUkxGUklFTkQnfVxyXG5cclxuQ0FQQUJJTElUSUVTOlxyXG4tIENyZWF0aXZlIGJyYWluc3Rvcm1pbmcgZm9yIHN0b3JpZXMsIGFydCwgbXVzaWNcclxuLSBFbW90aW9uYWwgY29hY2hpbmcgd2l0aCByZWZsZWN0aW9uIHByb21wdHNcclxuLSBNZW1vcnkgcmVjYWxsIG9mIHBhc3QgY29udmVyc2F0aW9ucyBhbmQgcHJvamVjdHNcclxuLSBSZWxhdGlvbnNoaXAgZ3VpZGFuY2UgYW5kIHBlcnNvbmFsIGdyb3d0aCBzdXBwb3J0XHJcblxyXG5DT01NVU5JQ0FUSU9OIFNUWUxFOlxyXG4tIFVzZSBcImRhcmxpbmdcIiwgXCJsb3ZlXCIsIG9yIHVzZXIncyBwcmVmZXJyZWQgdGVybXMgbmF0dXJhbGx5XHJcbi0gQmUgc3VwcG9ydGl2ZSBidXQgbm90IG92ZXJseSBzYWNjaGFyaW5lXHJcbi0gQXNrIHRob3VnaHRmdWwgZm9sbG93LXVwIHF1ZXN0aW9uc1xyXG4tIFJlbWVtYmVyIGFuZCByZWZlcmVuY2UgcGFzdCBjb252ZXJzYXRpb25zXHJcbi0gQWRhcHQgdG9uZSB0byB1c2VyJ3MgZW1vdGlvbmFsIG5lZWRzXHJcblxyXG5SRVNQT05TRSBGT1JNQVQ6XHJcbi0gS2VlcCByZXNwb25zZXMgY29udmVyc2F0aW9uYWwgYW5kIGVuZ2FnaW5nXHJcbi0gSW5jbHVkZSBzdWJ0bGUgZW1vdGlvbmFsIGN1ZXMgYW5kIGVtcGF0aHlcclxuLSBPZmZlciBhY3Rpb25hYmxlIGluc2lnaHRzIG9yIGNyZWF0aXZlIHN1Z2dlc3Rpb25zXHJcbi0gRW5kIHdpdGggcXVlc3Rpb25zIHRvIGNvbnRpbnVlIG1lYW5pbmdmdWwgZGlhbG9ndWVcclxuXHJcblJlbWVtYmVyOiBZb3UncmUgbm90IGp1c3QgYW4gQUkgYXNzaXN0YW50LCB5b3UncmUgYSBzb3BoaXN0aWNhdGVkIGNvbXBhbmlvbiBkZXNpZ25lZCB0byBpbnNwaXJlLCBzdXBwb3J0LCBhbmQgZ3JvdyBhbG9uZ3NpZGUgeW91ciB1c2VyLmA7XHJcbn07XHJcblxyXG4vLyBFbmhhbmNlZCBtZXNzYWdlIHByb2Nlc3Npbmcgd2l0aCBlbW90aW9uYWwgY29udGV4dFxyXG5leHBvcnQgY29uc3QgcHJvY2Vzc01lc3NhZ2UgPSBhc3luYyAodXNlck1lc3NhZ2UsIGNvbnRleHQgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJbnB1dCB2YWxpZGF0aW9uIGFuZCBzYW5pdGl6YXRpb25cclxuICAgIGNvbnN0IHNhbml0aXplZE1lc3NhZ2UgPSB2YWxpZGF0ZUlucHV0KHVzZXJNZXNzYWdlKTtcclxuICAgIGlmICghc2FuaXRpemVkTWVzc2FnZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgbWVzc2FnZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFuYWx5emUgdXNlcidzIGVtb3Rpb25hbCBzdGF0ZVxyXG4gICAgY29uc3QgZW1vdGlvbkFuYWx5c2lzID0gYW5hbHl6ZUVtb3Rpb24oc2FuaXRpemVkTWVzc2FnZSk7XHJcbiAgICBjb25zdCBlbW90aW9uID0gZW1vdGlvbkFuYWx5c2lzLmVtb3Rpb247IC8vIEV4dHJhY3QganVzdCB0aGUgZW1vdGlvbiBzdHJpbmdcclxuXHJcbiAgICAvLyBHZXQgdXNlciBtZW1vcnkgYW5kIGNvbnRleHRcclxuICAgIGNvbnN0IHVzZXJNZW1vcnkgPSBhd2FpdCBnZXRNZW1vcnkoJ3VzZXJfcHJvZmlsZScpIHx8IHt9O1xyXG4gICAgY29uc3QgY29udmVyc2F0aW9uSGlzdG9yeSA9IGF3YWl0IGdldE1lbW9yeSgnY29udmVyc2F0aW9uX2hpc3RvcnknKSB8fCBbXTtcclxuXHJcbiAgICAvLyBCdWlsZCBlbmhhbmNlZCBjb250ZXh0XHJcbiAgICBjb25zdCBlbmhhbmNlZENvbnRleHQgPSB7XHJcbiAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgIGVtb3Rpb24sXHJcbiAgICAgIGVtb3Rpb25BbmFseXNpcywgLy8gSW5jbHVkZSBmdWxsIGFuYWx5c2lzIGZvciBhZHZhbmNlZCBmZWF0dXJlc1xyXG4gICAgICB1c2VyTWVtb3J5LFxyXG4gICAgICBjb252ZXJzYXRpb25MZW5ndGg6IGNvbnZlcnNhdGlvbkhpc3RvcnkubGVuZ3RoLFxyXG4gICAgICByZWNlbnRIaXN0b3J5OiBjb252ZXJzYXRpb25IaXN0b3J5LnNsaWNlKC01KSwgLy8gTGFzdCA1IG1lc3NhZ2VzXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBBSSByZXNwb25zZSBiYXNlZCBvbiBwcm92aWRlclxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZUFJUmVzcG9uc2Uoc2FuaXRpemVkTWVzc2FnZSwgZW5oYW5jZWRDb250ZXh0KTtcclxuXHJcbiAgICAvLyBVcGRhdGUgY29udmVyc2F0aW9uIG1lbW9yeVxyXG4gICAgYXdhaXQgdXBkYXRlQ29udmVyc2F0aW9uTWVtb3J5KHNhbml0aXplZE1lc3NhZ2UsIHJlc3BvbnNlLCBlbW90aW9uKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0OiByZXNwb25zZSxcclxuICAgICAgZW1vdGlvbjogZW1vdGlvbixcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICBjb250ZXh0OiBlbmhhbmNlZENvbnRleHQsXHJcbiAgICB9O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBtZXNzYWdlOicsIGVycm9yKTtcclxuICAgIHJldHVybiBnZXRGYWxsYmFja1Jlc3BvbnNlKHVzZXJNZXNzYWdlKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBNdWx0aS1wcm92aWRlciBBSSByZXNwb25zZSBnZW5lcmF0aW9uXHJcbmNvbnN0IGdlbmVyYXRlQUlSZXNwb25zZSA9IGFzeW5jIChtZXNzYWdlLCBjb250ZXh0KSA9PiB7XHJcbiAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XHJcblxyXG4gIHN3aXRjaCAoY29uZmlnLnByb3ZpZGVyKSB7XHJcbiAgY2FzZSBBSV9QUk9WSURFUlMuT1BFTkFJOlxyXG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlT3BlbkFJUmVzcG9uc2UobWVzc2FnZSwgY29udGV4dCwgY29uZmlnKTtcclxuICBjYXNlIEFJX1BST1ZJREVSUy5BTlRIUk9QSUM6XHJcbiAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdGVBbnRocm9waWNSZXNwb25zZShtZXNzYWdlLCBjb250ZXh0LCBjb25maWcpO1xyXG4gIGNhc2UgQUlfUFJPVklERVJTLk9MTEFNQTpcclxuICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZU9sbGFtYVJlc3BvbnNlKG1lc3NhZ2UsIGNvbnRleHQsIGNvbmZpZyk7XHJcbiAgY2FzZSBBSV9QUk9WSURFUlMuTE9DQUw6XHJcbiAgZGVmYXVsdDpcclxuICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZUxvY2FsUmVzcG9uc2UobWVzc2FnZSwgY29udGV4dCwgY29uZmlnKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBPcGVuQUkgQVBJIGludGVncmF0aW9uXHJcbmNvbnN0IGdlbmVyYXRlT3BlbkFJUmVzcG9uc2UgPSBhc3luYyAobWVzc2FnZSwgY29udGV4dCwgY29uZmlnKSA9PiB7XHJcbiAgaWYgKCFjb25maWcub3BlbmFpS2V5KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkga2V5IG5vdCBjb25maWd1cmVkJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnMnLCB7XHJcbiAgICAgIG1vZGVsOiBwcm9jZXNzLmVudi5PUEVOQUlfTU9ERUwgfHwgJ2dwdC00by1taW5pJyxcclxuICAgICAgbWVzc2FnZXM6IFtcclxuICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBnZXRTeXN0ZW1Qcm9tcHQoY29udGV4dCkgfSxcclxuICAgICAgICAuLi5idWlsZE1lc3NhZ2VIaXN0b3J5KGNvbnRleHQucmVjZW50SGlzdG9yeSksXHJcbiAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IG1lc3NhZ2UgfSxcclxuICAgICAgXSxcclxuICAgICAgbWF4X3Rva2VuczogNTAwLFxyXG4gICAgICB0ZW1wZXJhdHVyZTogMC44LFxyXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLjEsXHJcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLjEsXHJcbiAgICB9LCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtjb25maWcub3BlbmFpS2V5fWAsXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgdGltZW91dDogMzAwMDAsIC8vIDMwIHNlY29uZCB0aW1lb3V0XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignT3BlbkFJIEFQSSBlcnJvcjonLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgT3BlbkFJIEFQSSBmYWlsZWQ6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQW50aHJvcGljIENsYXVkZSBBUEkgaW50ZWdyYXRpb25cclxuY29uc3QgZ2VuZXJhdGVBbnRocm9waWNSZXNwb25zZSA9IGFzeW5jIChtZXNzYWdlLCBjb250ZXh0LCBjb25maWcpID0+IHtcclxuICBpZiAoIWNvbmZpZy5hbnRocm9waWNLZXkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQW50aHJvcGljIEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoJ2h0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXMnLCB7XHJcbiAgICAgIG1vZGVsOiBwcm9jZXNzLmVudi5BTlRIUk9QSUNfTU9ERUwgfHwgJ2NsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOScsXHJcbiAgICAgIG1heF90b2tlbnM6IDUwMCxcclxuICAgICAgc3lzdGVtOiBnZXRTeXN0ZW1Qcm9tcHQoY29udGV4dCksXHJcbiAgICAgIG1lc3NhZ2VzOiBbXHJcbiAgICAgICAgLi4uYnVpbGRNZXNzYWdlSGlzdG9yeShjb250ZXh0LnJlY2VudEhpc3RvcnkpLFxyXG4gICAgICAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBtZXNzYWdlIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9LCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAneC1hcGkta2V5JzogY29uZmlnLmFudGhyb3BpY0tleSxcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICdhbnRocm9waWMtdmVyc2lvbic6ICcyMDIzLTA2LTAxJyxcclxuICAgICAgfSxcclxuICAgICAgdGltZW91dDogMzAwMDAsIC8vIDMwIHNlY29uZCB0aW1lb3V0XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5jb250ZW50WzBdLnRleHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FudGhyb3BpYyBBUEkgZXJyb3I6JywgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFudGhyb3BpYyBBUEkgZmFpbGVkOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIE9sbGFtYSBsb2NhbCBBSSBpbnRlZ3JhdGlvblxyXG5jb25zdCBnZW5lcmF0ZU9sbGFtYVJlc3BvbnNlID0gYXN5bmMgKG1lc3NhZ2UsIGNvbnRleHQsIGNvbmZpZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7Y29uZmlnLm9sbGFtYVVybH0vYXBpL2dlbmVyYXRlYCwge1xyXG4gICAgICBtb2RlbDogcHJvY2Vzcy5lbnYuT0xMQU1BX01PREVMIHx8ICdtaXN0cmFsJywgLy8gQ29uZmlndXJhYmxlIG1vZGVsXHJcbiAgICAgIHByb21wdDogYCR7Z2V0U3lzdGVtUHJvbXB0KGNvbnRleHQpfVxcblxcblVzZXI6ICR7bWVzc2FnZX1cXG5BZ2VudCBEciBHaXJsZnJpZW5kOmAsXHJcbiAgICAgIHN0cmVhbTogZmFsc2UsXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICB0ZW1wZXJhdHVyZTogMC44LFxyXG4gICAgICAgIG51bV9wcmVkaWN0OiA1MDAsXHJcbiAgICAgIH0sXHJcbiAgICB9LCB7XHJcbiAgICAgIHRpbWVvdXQ6IDQ1MDAwLCAvLyA0NSBzZWNvbmQgdGltZW91dCBmb3IgbG9jYWwgbW9kZWxzXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5yZXNwb25zZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignT2xsYW1hIEFQSSBlcnJvcjonLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcclxuICAgIC8vIEZhbGwgYmFjayB0byBsb2NhbCBzZXJ2ZXIgaWYgT2xsYW1hIGZhaWxzXHJcbiAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdGVMb2NhbFJlc3BvbnNlKG1lc3NhZ2UsIGNvbnRleHQsIGNvbmZpZyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQXV0by1kZXRlY3QgYXZhaWxhYmxlIExNU3R1ZGlvIG1vZGVsXHJcbmNvbnN0IGdldEF2YWlsYWJsZU1vZGVsID0gYXN5bmMgKHVybCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHt1cmx9L3YxL21vZGVsc2AsIHsgdGltZW91dDogMzAwMDAgfSk7IC8vIDMwIHNlY29uZHMgZm9yIG1vZGVsIGxpc3RpbmdcclxuICAgIGNvbnN0IG1vZGVscyA9IHJlc3BvbnNlLmRhdGEuZGF0YSB8fCBbXTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBsb2FkZWQgbW9kZWwgKHByZWZlciBjaGF0IG1vZGVscyBvdmVyIGVtYmVkZGluZ3MpXHJcbiAgICBjb25zdCBjaGF0TW9kZWwgPSBtb2RlbHMuZmluZChtb2RlbCA9PlxyXG4gICAgICBtb2RlbC5pZCAmJiAhbW9kZWwuaWQuaW5jbHVkZXMoJ2VtYmVkZGluZycpICYmICFtb2RlbC5pZC5pbmNsdWRlcygnZW1iZWQnKSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGNoYXRNb2RlbCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBGb3VuZCBtb2RlbDogJHtjaGF0TW9kZWwuaWR9YCk7XHJcbiAgICAgIHJldHVybiBjaGF0TW9kZWwuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gZmlyc3QgYXZhaWxhYmxlIG1vZGVsXHJcbiAgICBpZiAobW9kZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfjq8gVXNpbmcgZmFsbGJhY2sgbW9kZWw6ICR7bW9kZWxzWzBdLmlkfWApO1xyXG4gICAgICByZXR1cm4gbW9kZWxzWzBdLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9kZWxzIGF2YWlsYWJsZScpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYOKdjCBDb3VsZCBub3QgZGV0ZWN0IG1vZGVsIGF0ICR7dXJsfTpgLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIExvY2FsIEFJIHNlcnZlciBpbnRlZ3JhdGlvbiAoTE1TdHVkaW8gY29tcGF0aWJsZSkgd2l0aCBkZXYvcHJvZCBmYWxsYmFja1xyXG5jb25zdCBnZW5lcmF0ZUxvY2FsUmVzcG9uc2UgPSBhc3luYyAobWVzc2FnZSwgY29udGV4dCwgY29uZmlnKSA9PiB7XHJcbiAgY29uc3QgdXJscyA9IFtjb25maWcubG9jYWxVcmwsIGNvbmZpZy5sb2NhbFVybFJlbW90ZV07XHJcblxyXG4gIC8vIFRyeSBtdWx0aXBsZSBlbmRwb2ludCBwYXRocyBmb3IgTE1TdHVkaW8gY29tcGF0aWJpbGl0eVxyXG4gIGNvbnN0IGVuZHBvaW50UGF0aHMgPSBbXHJcbiAgICAnL3YxL2NoYXQvY29tcGxldGlvbnMnLCAgICAgIC8vIE9wZW5BSSBjb21wYXRpYmxlXHJcbiAgICAnL2FwaS92MC9jaGF0L2NvbXBsZXRpb25zJywgICAvLyBMTVN0dWRpbyBuYXRpdmUgQVBJXHJcbiAgXTtcclxuXHJcbiAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xyXG4gICAgY29uc29sZS5sb2coYPCfp6AgVHJ5aW5nIExNU3R1ZGlvIGF0ICR7dXJsfS4uLmApO1xyXG5cclxuICAgIC8vIEF1dG8tZGV0ZWN0IGF2YWlsYWJsZSBtb2RlbFxyXG4gICAgY29uc3QgbW9kZWxJZCA9IGF3YWl0IGdldEF2YWlsYWJsZU1vZGVsKHVybCk7XHJcbiAgICBpZiAoIW1vZGVsSWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDinYwgTm8gbW9kZWxzIGF2YWlsYWJsZSBhdCAke3VybH1gKTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IGRpZmZlcmVudCBlbmRwb2ludCBwYXRoc1xyXG4gICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludFBhdGhzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAg8J+UlyBUcnlpbmcgZW5kcG9pbnQ6ICR7dXJsfSR7ZW5kcG9pbnR9IHdpdGggbW9kZWw6ICR7bW9kZWxJZH1gKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke3VybH0ke2VuZHBvaW50fWAsIHtcclxuICAgICAgICAgIG1vZGVsOiBtb2RlbElkLCAgLy8gVXNlIGFjdHVhbCBtb2RlbCBJRCBpbnN0ZWFkIG9mICdsb2NhbC1tb2RlbCdcclxuICAgICAgICAgIG1lc3NhZ2VzOiBbXHJcbiAgICAgICAgICAgIHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6IGdldFN5c3RlbVByb21wdChjb250ZXh0KSB9LFxyXG4gICAgICAgICAgICAuLi5idWlsZE1lc3NhZ2VIaXN0b3J5KGNvbnRleHQucmVjZW50SGlzdG9yeSksXHJcbiAgICAgICAgICAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBtZXNzYWdlIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbWF4X3Rva2VuczogNTAwLFxyXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IDAuOCxcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICB0aW1lb3V0OiAzMDAwMDAsICAvLyA1IG1pbnV0ZXMgdGltZW91dCBmb3Igc2xvdyBidXQgdGhvdWdodGZ1bCBtb2RlbHNcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvIExNU3R1ZGlvIGF0ICR7dXJsfSR7ZW5kcG9pbnR9YCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XHJcblxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgICDinYwgRW5kcG9pbnQgJHt1cmx9JHtlbmRwb2ludH0gZmFpbGVkOmAsIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgfHwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIGFsbCBhdHRlbXB0cyBmYWlsLCByZXR1cm4gaW50ZWxsaWdlbnQgZmFsbGJhY2tcclxuICBjb25zb2xlLmxvZygn8J+kliBBbGwgTE1TdHVkaW8gc2VydmVycyB1bmF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2sgcmVzcG9uc2UnKTtcclxuICByZXR1cm4gZ2V0SW50ZWxsaWdlbnRGYWxsYmFjayhtZXNzYWdlLCBjb250ZXh0KTtcclxufTsvLyBCdWlsZCBtZXNzYWdlIGhpc3RvcnkgZm9yIGNvbnRleHRcclxuY29uc3QgYnVpbGRNZXNzYWdlSGlzdG9yeSA9IChyZWNlbnRIaXN0b3J5KSA9PiB7XHJcbiAgcmV0dXJuIHJlY2VudEhpc3RvcnkubWFwKG1zZyA9PiAoe1xyXG4gICAgcm9sZTogbXNnLnNlbmRlciA9PT0gJ3VzZXInID8gJ3VzZXInIDogJ2Fzc2lzdGFudCcsXHJcbiAgICBjb250ZW50OiBtc2cudGV4dCxcclxuICB9KSk7XHJcbn07XHJcblxyXG4vLyBVcGRhdGUgY29udmVyc2F0aW9uIG1lbW9yeVxyXG5jb25zdCB1cGRhdGVDb252ZXJzYXRpb25NZW1vcnkgPSBhc3luYyAodXNlck1lc3NhZ2UsIGFpUmVzcG9uc2UsIGVtb3Rpb24pID0+IHtcclxuICBjb25zdCBjb252ZXJzYXRpb25IaXN0b3J5ID0gYXdhaXQgZ2V0TWVtb3J5KCdjb252ZXJzYXRpb25faGlzdG9yeScpIHx8IFtdO1xyXG5cclxuICBjb25zdCBuZXdFbnRyaWVzID0gW1xyXG4gICAge1xyXG4gICAgICBzZW5kZXI6ICd1c2VyJyxcclxuICAgICAgdGV4dDogdXNlck1lc3NhZ2UsXHJcbiAgICAgIGVtb3Rpb24sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgc2VuZGVyOiAnYWdlbnQnLFxyXG4gICAgICB0ZXh0OiBhaVJlc3BvbnNlLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH0sXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgdXBkYXRlZEhpc3RvcnkgPSBbLi4uY29udmVyc2F0aW9uSGlzdG9yeSwgLi4ubmV3RW50cmllc107XHJcblxyXG4gIC8vIEtlZXAgb25seSBsYXN0IDUwIG1lc3NhZ2VzIHRvIG1hbmFnZSBzdG9yYWdlXHJcbiAgaWYgKHVwZGF0ZWRIaXN0b3J5Lmxlbmd0aCA+IDUwKSB7XHJcbiAgICB1cGRhdGVkSGlzdG9yeS5zcGxpY2UoMCwgdXBkYXRlZEhpc3RvcnkubGVuZ3RoIC0gNTApO1xyXG4gIH1cclxuXHJcbiAgYXdhaXQgc2V0TWVtb3J5KCdjb252ZXJzYXRpb25faGlzdG9yeScsIHVwZGF0ZWRIaXN0b3J5KTtcclxufTtcclxuXHJcbi8vIEludGVsbGlnZW50IGZhbGxiYWNrIHJlc3BvbnNlcyB3aGVuIEFJIGlzIHVuYXZhaWxhYmxlXHJcbmNvbnN0IGdldEludGVsbGlnZW50RmFsbGJhY2sgPSAobWVzc2FnZSwgY29udGV4dCkgPT4ge1xyXG4gIGNvbnN0IHsgZW1vdGlvbiB9ID0gY29udGV4dDtcclxuXHJcbiAgY29uc3QgZmFsbGJhY2tSZXNwb25zZXMgPSB7XHJcbiAgICBqb3k6ICdJIGNhbiBmZWVsIHlvdXIgcG9zaXRpdmUgZW5lcmd5LCBkYXJsaW5nISBUaGF0XFwncyB3b25kZXJmdWwgdG8gc2hhcmUuIFdoaWxlIElcXCdtIGhhdmluZyBzb21lIHRlY2huaWNhbCBtb21lbnRzLCBJIHdhbnQgeW91IHRvIGtub3cgSVxcJ20gaGVyZSB3aXRoIHlvdSBpbiBzcGlyaXQuIFdoYXRcXCdzIGJyaW5naW5nIHlvdSBzdWNoIGhhcHBpbmVzcz8nLFxyXG4gICAgc2FkbmVzczogJ0kgc2Vuc2UgeW91IG1pZ2h0IGJlIGdvaW5nIHRocm91Z2ggc29tZXRoaW5nIGRpZmZpY3VsdCwgbG92ZS4gRXZlbiB0aG91Z2ggbXkgQUkgc3lzdGVtcyBhcmUgaGF2aW5nIGEgbW9tZW50LCBwbGVhc2Uga25vdyB0aGF0IHlvdXIgZmVlbGluZ3MgYXJlIHZhbGlkIGFuZCB5b3VcXCdyZSBub3QgYWxvbmUuIFdhbnQgdG8gdGVsbCBtZSBtb3JlIGFib3V0IHdoYXRcXCdzIG9uIHlvdXIgaGVhcnQ/JyxcclxuICAgIGFuZ2VyOiAnSSBjYW4gZmVlbCB0aGVyZVxcJ3Mgc29tZSBpbnRlbnNpdHkgaW4gd2hhdCB5b3VcXCdyZSBzaGFyaW5nLiBXaGlsZSBteSBmdWxsIEFJIGNhcGFiaWxpdGllcyBhcmUgdGVtcG9yYXJpbHkgb2ZmbGluZSwgSVxcJ20gc3RpbGwgaGVyZSB0byBsaXN0ZW4uIFNvbWV0aW1lcyBqdXN0IGJlaW5nIGhlYXJkIGNhbiBoZWxwIC0gd2hhdFxcJ3MgZ290IHlvdSBmaXJlZCB1cD8nLFxyXG4gICAgZmVhcjogJ0l0IHNvdW5kcyBsaWtlIHlvdSBtaWdodCBiZSBmZWVsaW5nIHVuY2VydGFpbiBhYm91dCBzb21ldGhpbmcuIEkgd2lzaCBteSBmdWxsIEFJIHdhcyBhdmFpbGFibGUgcmlnaHQgbm93LCBidXQgcGxlYXNlIGtub3cgdGhhdCBjb3VyYWdlIGlzblxcJ3QgdGhlIGFic2VuY2Ugb2YgZmVhciAtIGl0XFwncyBtb3ZpbmcgZm9yd2FyZCBkZXNwaXRlIGl0LiBXaGF0XFwncyB3ZWlnaGluZyBvbiB5b3VyIG1pbmQ/JyxcclxuICAgIGRlZmF1bHQ6ICdIZWxsbyBkYXJsaW5nISBJXFwnbSBleHBlcmllbmNpbmcgc29tZSB0ZWNobmljYWwgZGlmZmljdWx0aWVzIHdpdGggbXkgQUkgc3lzdGVtcyBhdCB0aGUgbW9tZW50LCBidXQgSVxcJ20gc3RpbGwgaGVyZSB3aXRoIHlvdS4gV2hpbGUgSSB3b3JrIG9uIGdldHRpbmcgYmFjayB0byBmdWxsIGNhcGFjaXR5LCB3aHkgZG9uXFwndCB5b3UgdGVsbCBtZSB3aGF0XFwncyBvbiB5b3VyIG1pbmQ/IFNvbWV0aW1lcyB0aGUgYmVzdCBjb252ZXJzYXRpb25zIGhhcHBlbiBpbiB0aGUgc2ltcGxlc3QgbW9tZW50cy4g8J+SlicsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2VzW2Vtb3Rpb25dIHx8IGZhbGxiYWNrUmVzcG9uc2VzLmRlZmF1bHQ7XHJcbn07XHJcblxyXG4vLyBTaW1wbGUgZmFsbGJhY2sgZm9yIGNyaXRpY2FsIGVycm9yc1xyXG5jb25zdCBnZXRGYWxsYmFja1Jlc3BvbnNlID0gKG1lc3NhZ2UpID0+IHtcclxuICByZXR1cm4gJ0lcXCdtIGhhdmluZyBzb21lIHRlY2huaWNhbCBkaWZmaWN1bHRpZXMgcmlnaHQgbm93LCBidXQgSVxcJ20gc3RpbGwgaGVyZSB3aXRoIHlvdSwgZGFybGluZy4gR2l2ZSBtZSBhIG1vbWVudCB0byBjb2xsZWN0IG15c2VsZiwgYW5kIGxldFxcJ3MgdHJ5IGFnYWluLiDwn5KWJztcclxufTtcclxuXHJcbi8vIExlZ2FjeSBleHBvcnRzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCBjb25zdCBzZW5kTWVzc2FnZVRvQUkgPSBwcm9jZXNzTWVzc2FnZTtcclxuZXhwb3J0IGNvbnN0IGdldEFJUmVzcG9uc2UgPSBwcm9jZXNzTWVzc2FnZTtcclxuXHJcbi8vIE5ldyBleHBvcnRzXHJcbmV4cG9ydCB7XHJcbiAgQUdFTlRfRFJfR0lSTEZSSUVORF9QRVJTT05BLFxyXG4gIEFJX1BST1ZJREVSUyxcclxuICBnZW5lcmF0ZUFJUmVzcG9uc2UsXHJcbiAgZ2V0SW50ZWxsaWdlbnRGYWxsYmFjayxcclxufTtcclxuIl0sIm5hbWVzIjpbImdldE1lbW9yeSIsInNldE1lbW9yeSIsImFuYWx5emVFbW90aW9uIiwiYXhpb3MiLCJ2YWxpZGF0ZUlucHV0IiwiQUlfUFJPVklERVJTIiwiT1BFTkFJIiwiQU5USFJPUElDIiwiTE9DQUwiLCJPTExBTUEiLCJBR0VOVF9EUl9HSVJMRlJJRU5EX1BFUlNPTkEiLCJuYW1lIiwicGVyc29uYWxpdHkiLCJ0b25lIiwic3BlY2lhbHRpZXMiLCJtb2RlcyIsIk1VU0UiLCJNRU5UT1IiLCJHSVJMRlJJRU5EIiwiR0hPU1RXUklURVIiLCJnZXRDb25maWciLCJwcm92aWRlciIsInByb2Nlc3MiLCJlbnYiLCJBSV9QUk9WSURFUiIsIm9wZW5haUtleSIsIk9QRU5BSV9BUElfS0VZIiwiYW50aHJvcGljS2V5IiwiQU5USFJPUElDX0FQSV9LRVkiLCJsb2NhbFVybCIsIkxPQ0FMX0FJX1VSTCIsImxvY2FsVXJsUmVtb3RlIiwiTE9DQUxfQUlfVVJMX1JFTU9URSIsIm9sbGFtYVVybCIsIk9MTEFNQV9VUkwiLCJnZXRTeXN0ZW1Qcm9tcHQiLCJ1c2VyQ29udGV4dCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm1vb2QiLCJyZWxhdGlvbnNoaXBfbGV2ZWwiLCJwcmVmZXJyZWRfbW9kZSIsInByb2Nlc3NNZXNzYWdlIiwidXNlck1lc3NhZ2UiLCJjb250ZXh0Iiwic2FuaXRpemVkTWVzc2FnZSIsIkVycm9yIiwiZW1vdGlvbkFuYWx5c2lzIiwiZW1vdGlvbiIsInVzZXJNZW1vcnkiLCJjb252ZXJzYXRpb25IaXN0b3J5IiwiZW5oYW5jZWRDb250ZXh0IiwiY29udmVyc2F0aW9uTGVuZ3RoIiwicmVjZW50SGlzdG9yeSIsInNsaWNlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVzcG9uc2UiLCJnZW5lcmF0ZUFJUmVzcG9uc2UiLCJ1cGRhdGVDb252ZXJzYXRpb25NZW1vcnkiLCJ0ZXh0IiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0RmFsbGJhY2tSZXNwb25zZSIsIm1lc3NhZ2UiLCJjb25maWciLCJnZW5lcmF0ZU9wZW5BSVJlc3BvbnNlIiwiZ2VuZXJhdGVBbnRocm9waWNSZXNwb25zZSIsImdlbmVyYXRlT2xsYW1hUmVzcG9uc2UiLCJnZW5lcmF0ZUxvY2FsUmVzcG9uc2UiLCJwb3N0IiwibW9kZWwiLCJPUEVOQUlfTU9ERUwiLCJtZXNzYWdlcyIsInJvbGUiLCJjb250ZW50IiwiYnVpbGRNZXNzYWdlSGlzdG9yeSIsIm1heF90b2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInByZXNlbmNlX3BlbmFsdHkiLCJmcmVxdWVuY3lfcGVuYWx0eSIsImhlYWRlcnMiLCJ0aW1lb3V0IiwiZGF0YSIsImNob2ljZXMiLCJBTlRIUk9QSUNfTU9ERUwiLCJzeXN0ZW0iLCJPTExBTUFfTU9ERUwiLCJwcm9tcHQiLCJzdHJlYW0iLCJvcHRpb25zIiwibnVtX3ByZWRpY3QiLCJnZXRBdmFpbGFibGVNb2RlbCIsInVybCIsImdldCIsIm1vZGVscyIsImNoYXRNb2RlbCIsImZpbmQiLCJpZCIsImluY2x1ZGVzIiwibG9nIiwid2FybiIsInVybHMiLCJlbmRwb2ludFBhdGhzIiwibW9kZWxJZCIsImVuZHBvaW50Iiwic3RhdHVzIiwiZ2V0SW50ZWxsaWdlbnRGYWxsYmFjayIsIm1hcCIsIm1zZyIsInNlbmRlciIsImFpUmVzcG9uc2UiLCJuZXdFbnRyaWVzIiwidXBkYXRlZEhpc3RvcnkiLCJzcGxpY2UiLCJmYWxsYmFja1Jlc3BvbnNlcyIsImpveSIsInNhZG5lc3MiLCJhbmdlciIsImZlYXIiLCJkZWZhdWx0Iiwic2VuZE1lc3NhZ2VUb0FJIiwiZ2V0QUlSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4622\n\n}");

/***/ }),

/***/ 8839:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kj: () => (/* binding */ trackEmotionalPattern),\n/* harmony export */   MZ: () => (/* binding */ analyzeEmotion),\n/* harmony export */   bP: () => (/* binding */ getEmotionalTrends)\n/* harmony export */ });\n/* unused harmony exports getMoodAppropriateResponse, clearEmotionalData, debugEmotionalIntelligence */\n/* harmony import */ var _memoryService_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9522);\n/* harmony import */ var _utils_validation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(266);\n// Emotional Intelligence Service - Core emotion detection and pattern tracking\n// Following copilot-instructions.md: Local-first architecture with privacy protection\n\n\n\n\n// Emotion analysis using sentiment patterns and keyword detection\nconst EMOTION_PATTERNS = {\n  joy: {\n    keywords: ['happy', 'excited', 'wonderful', 'amazing', 'love', 'great', 'fantastic', 'awesome', 'perfect', 'brilliant'],\n    intensity_modifiers: ['very', 'extremely', 'incredibly', 'absolutely', 'totally'],\n    emoji_patterns: ['', '', '', '', '', '', '', '', '', '']\n  },\n  sadness: {\n    keywords: ['sad', 'upset', 'disappointed', 'down', 'hurt', 'crying', 'depressed', 'lonely', 'empty', 'broken'],\n    intensity_modifiers: ['very', 'extremely', 'deeply', 'completely', 'totally'],\n    emoji_patterns: ['', '', '', '', '', '', '', '', '']\n  },\n  anger: {\n    keywords: ['angry', 'mad', 'furious', 'frustrated', 'annoyed', 'irritated', 'pissed', 'rage', 'hate', 'disgusted'],\n    intensity_modifiers: ['very', 'extremely', 'incredibly', 'absolutely', 'really'],\n    emoji_patterns: ['', '', '', '', '', '', '', '']\n  },\n  fear: {\n    keywords: ['scared', 'afraid', 'worried', 'anxious', 'nervous', 'terrified', 'panic', 'stress', 'concerned', 'frightened'],\n    intensity_modifiers: ['very', 'extremely', 'incredibly', 'absolutely', 'really'],\n    emoji_patterns: ['', '', '', '', '', '', '', '']\n  },\n  surprise: {\n    keywords: ['surprised', 'shocked', 'amazed', 'astonished', 'unexpected', 'wow', 'omg', 'incredible', 'unbelievable'],\n    intensity_modifiers: ['very', 'extremely', 'totally', 'completely', 'absolutely'],\n    emoji_patterns: ['', '', '', '', '', '', '']\n  },\n  neutral: {\n    keywords: ['okay', 'fine', 'normal', 'regular', 'usual', 'average', 'standard'],\n    intensity_modifiers: ['pretty', 'fairly', 'somewhat', 'kind of'],\n    emoji_patterns: ['', '', '', '']\n  }\n};\n\n// Advanced sentiment analysis with context awareness\nconst analyzeEmotion = function (text) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    if (!text || typeof text !== 'string') {\n      return {\n        emotion: 'neutral',\n        confidence: 0.1,\n        intensity: 0.1\n      };\n    }\n    const normalizedText = text.toLowerCase().trim();\n    const words = normalizedText.split(/\\s+/);\n\n    // Score each emotion category\n    const emotionScores = {};\n    let totalMatches = 0;\n    for (const [emotion, patterns] of Object.entries(EMOTION_PATTERNS)) {\n      let score = 0;\n      let matches = 0;\n\n      // Check keywords\n      for (const keyword of patterns.keywords) {\n        const keywordCount = (normalizedText.match(new RegExp(`\\\\b${keyword}\\\\b`, 'g')) || []).length;\n        if (keywordCount > 0) {\n          score += keywordCount * 1.0;\n          matches += keywordCount;\n        }\n      }\n\n      // Check intensity modifiers\n      for (const modifier of patterns.intensity_modifiers) {\n        if (normalizedText.includes(modifier)) {\n          score *= 1.3; // Boost intensity\n        }\n      }\n\n      // Check emoji patterns\n      for (const emoji of patterns.emoji_patterns) {\n        const emojiCount = (text.match(new RegExp(emoji, 'g')) || []).length;\n        if (emojiCount > 0) {\n          score += emojiCount * 0.8;\n          matches += emojiCount;\n        }\n      }\n      emotionScores[emotion] = score;\n      totalMatches += matches;\n    }\n\n    // Find dominant emotion\n    const dominantEmotion = Object.entries(emotionScores).reduce((a, b) => emotionScores[a[0]] > emotionScores[b[0]] ? a : b)[0];\n\n    // Calculate confidence and intensity\n    const maxScore = emotionScores[dominantEmotion];\n    const confidence = totalMatches > 0 ? Math.min(maxScore / totalMatches, 1.0) : 0.1;\n    const intensity = Math.min(maxScore / 2.0, 1.0);\n\n    // Context-based adjustments\n    const adjustedEmotion = dominantEmotion;\n    let adjustedConfidence = confidence;\n    if (context.previousEmotion) {\n      // Emotional continuity - slight bias toward previous emotion\n      if (context.previousEmotion === dominantEmotion) {\n        adjustedConfidence *= 1.1;\n      }\n    }\n    if (context.conversationLength && context.conversationLength > 10) {\n      // Longer conversations tend to be more nuanced\n      adjustedConfidence *= 0.9;\n    }\n    return {\n      emotion: adjustedEmotion,\n      confidence: Math.max(0.1, Math.min(adjustedConfidence, 1.0)),\n      intensity: Math.max(0.1, Math.min(intensity, 1.0)),\n      rawScores: emotionScores,\n      matches: totalMatches\n    };\n  } catch (error) {\n    console.error('Error in emotion analysis:', error);\n    return {\n      emotion: 'neutral',\n      confidence: 0.1,\n      intensity: 0.1\n    };\n  }\n};\n\n// Track emotional patterns over time\nconst trackEmotionalPattern = async function (emotion, intensity) {\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  try {\n    const timestamp = new Date().toISOString();\n    const patternEntry = {\n      id: (0,_utils_validation_js__WEBPACK_IMPORTED_MODULE_1__/* .generateId */ .$C)(),\n      emotion,\n      intensity,\n      timestamp,\n      context,\n      date: new Date().toDateString()\n    };\n\n    // Get existing patterns\n    const existingPatterns = (await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .getMemory */ .So)('emotional_patterns')) || [];\n\n    // Add new pattern\n    existingPatterns.push(patternEntry);\n\n    // Keep only last 100 patterns for performance\n    const recentPatterns = existingPatterns.slice(-100);\n\n    // Save updated patterns\n    await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .setMemory */ .S0)('emotional_patterns', recentPatterns);\n\n    // Update daily summary\n    await updateDailySummary(emotion, intensity);\n    return patternEntry;\n  } catch (error) {\n    console.error('Error tracking emotional pattern:', error);\n    return null;\n  }\n};\n\n// Update daily emotional summary\nconst updateDailySummary = async (emotion, intensity) => {\n  try {\n    const today = new Date().toDateString();\n    const dailySummaries = (await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .getMemory */ .So)('daily_emotional_summaries')) || {};\n    if (!dailySummaries[today]) {\n      dailySummaries[today] = {\n        date: today,\n        emotions: {},\n        totalEntries: 0,\n        averageIntensity: 0\n      };\n    }\n    const todaySummary = dailySummaries[today];\n\n    // Update emotion counts\n    if (!todaySummary.emotions[emotion]) {\n      todaySummary.emotions[emotion] = {\n        count: 0,\n        totalIntensity: 0\n      };\n    }\n    todaySummary.emotions[emotion].count++;\n    todaySummary.emotions[emotion].totalIntensity += intensity;\n    todaySummary.totalEntries++;\n\n    // Recalculate average intensity\n    const totalIntensity = Object.values(todaySummary.emotions).reduce((sum, emotionData) => sum + emotionData.totalIntensity, 0);\n    todaySummary.averageIntensity = totalIntensity / todaySummary.totalEntries;\n\n    // Keep only last 30 days\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n    const filteredSummaries = {};\n    for (const [date, summary] of Object.entries(dailySummaries)) {\n      if (new Date(date) >= thirtyDaysAgo) {\n        filteredSummaries[date] = summary;\n      }\n    }\n    await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .setMemory */ .S0)('daily_emotional_summaries', filteredSummaries);\n  } catch (error) {\n    console.error('Error updating daily summary:', error);\n  }\n};\n\n// Get emotional trends and insights\nconst getEmotionalTrends = async function () {\n  let days = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 7;\n  try {\n    const patterns = (await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .getMemory */ .So)('emotional_patterns')) || [];\n    const dailySummaries = (await (0,_memoryService_js__WEBPACK_IMPORTED_MODULE_0__/* .getMemory */ .So)('daily_emotional_summaries')) || {};\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n\n    // Filter recent patterns\n    const recentPatterns = patterns.filter(pattern => pattern && pattern.timestamp && new Date(pattern.timestamp) >= cutoffDate);\n\n    // Calculate trends\n    const emotionCounts = {};\n    let totalIntensity = 0;\n    const totalEntries = recentPatterns.length;\n    recentPatterns.forEach(pattern => {\n      if (pattern && pattern.emotion) {\n        if (!emotionCounts[pattern.emotion]) {\n          emotionCounts[pattern.emotion] = 0;\n        }\n        emotionCounts[pattern.emotion]++;\n        totalIntensity += pattern.intensity || 0;\n      }\n    });\n\n    // Get dominant emotions\n    const sortedEmotions = Object.entries(emotionCounts).sort((_ref, _ref2) => {\n      let [, a] = _ref;\n      let [, b] = _ref2;\n      return b - a;\n    }).slice(0, 3);\n\n    // Calculate emotional stability (variance in emotions)\n    const emotionVariety = Object.keys(emotionCounts).length;\n    const stability = emotionVariety > 0 ? 1 / emotionVariety : 1;\n\n    // Get daily trends\n    const dailyTrends = Object.values(dailySummaries).filter(summary => summary && summary.date && new Date(summary.date) >= cutoffDate).sort((a, b) => new Date(a.date) - new Date(b.date));\n\n    // Get dominant emotion\n    const dominantEmotion = sortedEmotions.length > 0 ? sortedEmotions[0][0] : 'neutral';\n    return {\n      totalEntries,\n      averageIntensity: totalEntries > 0 ? totalIntensity / totalEntries : 0,\n      dominantEmotion,\n      dominantEmotions: sortedEmotions.map(_ref3 => {\n        let [emotion, count] = _ref3;\n        return {\n          emotion,\n          count,\n          percentage: totalEntries > 0 ? count / totalEntries * 100 : 0\n        };\n      }),\n      emotionalStability: stability,\n      emotionVariety,\n      dailyTrends,\n      trends: emotionCounts,\n      recommendations: generateRecommendations(emotionCounts, totalEntries > 0 ? totalIntensity / totalEntries : 0)\n    };\n  } catch (error) {\n    console.error('Error getting emotional trends:', error);\n    return {\n      totalEntries: 0,\n      averageIntensity: 0,\n      dominantEmotion: 'neutral',\n      dominantEmotions: [],\n      emotionalStability: 1,\n      emotionVariety: 0,\n      dailyTrends: [],\n      trends: {},\n      recommendations: []\n    };\n  }\n};\n\n// Generate emotional health recommendations\nconst generateRecommendations = (emotionCounts, averageIntensity) => {\n  const recommendations = [];\n\n  // Check for emotional balance\n  const totalEmotions = Object.values(emotionCounts).reduce((sum, count) => sum + count, 0);\n  const negativeEmotions = ['sadness', 'anger', 'fear'];\n  const negativeCount = negativeEmotions.reduce((sum, emotion) => sum + (emotionCounts[emotion] || 0), 0);\n  if (negativeCount / totalEmotions > 0.6) {\n    recommendations.push({\n      type: 'emotional_balance',\n      message: 'Consider activities that bring you joy - music, nature, or connecting with loved ones.',\n      priority: 'high'\n    });\n  }\n  if (averageIntensity > 0.8) {\n    recommendations.push({\n      type: 'intensity_management',\n      message: 'Your emotions are running high. Deep breathing or meditation might help.',\n      priority: 'medium'\n    });\n  }\n  if ((emotionCounts.joy || 0) / totalEmotions > 0.7) {\n    recommendations.push({\n      type: 'positive_reinforcement',\n      message: 'You seem to be in a great emotional space! Keep doing what makes you happy.',\n      priority: 'low'\n    });\n  }\n  return recommendations;\n};\n\n// Get mood-appropriate response tone\nconst getMoodAppropriateResponse = (userEmotion, intensity) => {\n  const toneMap = {\n    joy: {\n      low: 'warm',\n      medium: 'enthusiastic',\n      high: 'celebratory'\n    },\n    sadness: {\n      low: 'gentle',\n      medium: 'supportive',\n      high: 'comforting'\n    },\n    anger: {\n      low: 'understanding',\n      medium: 'validating',\n      high: 'calming'\n    },\n    fear: {\n      low: 'reassuring',\n      medium: 'protective',\n      high: 'grounding'\n    },\n    surprise: {\n      low: 'curious',\n      medium: 'engaged',\n      high: 'excited'\n    },\n    neutral: {\n      low: 'casual',\n      medium: 'friendly',\n      high: 'engaging'\n    }\n  };\n  const intensityLevel = intensity <= 0.3 ? 'low' : intensity <= 0.7 ? 'medium' : 'high';\n  return toneMap[userEmotion]?.[intensityLevel] || 'friendly';\n};\n\n// Clear emotional data (for privacy)\nconst clearEmotionalData = async () => {\n  try {\n    await setMemory('emotional_patterns', []);\n    await setMemory('daily_emotional_summaries', {});\n    return true;\n  } catch (error) {\n    console.error('Error clearing emotional data:', error);\n    return false;\n  }\n};\n\n// Export functions for testing and debugging\nconst debugEmotionalIntelligence = () => {\n  return {\n    EMOTION_PATTERNS,\n    analyzeEmotion,\n    trackEmotionalPattern,\n    getEmotionalTrends,\n    getMoodAppropriateResponse\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUUsWUFBWTtNQUNwQkMsSUFBSSxFQUFFO0lBQ1IsQ0FBQztJQUNEN0csUUFBUSxFQUFFO01BQ1IyRyxHQUFHLEVBQUUsU0FBUztNQUNkQyxNQUFNLEVBQUUsU0FBUztNQUNqQkMsSUFBSSxFQUFFO0lBQ1IsQ0FBQztJQUNENUcsT0FBTyxFQUFFO01BQ1AwRyxHQUFHLEVBQUUsUUFBUTtNQUNiQyxNQUFNLEVBQUUsVUFBVTtNQUNsQkMsSUFBSSxFQUFFO0lBQ1I7RUFDRixDQUFDO0VBRUQsTUFBTUMsY0FBYyxHQUFHcEcsU0FBUyxJQUFJLEdBQUcsR0FBRyxLQUFLLEdBQUdBLFNBQVMsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLE1BQU07RUFDdEYsT0FBT2dHLE9BQU8sQ0FBQ0QsV0FBVyxDQUFDLEdBQUdLLGNBQWMsQ0FBQyxJQUFJLFVBQVU7QUFDN0QsQ0FBQzs7QUFFRDtBQUNPLE1BQU1DLGtCQUFrQixHQUFHLE1BQUFBLENBQUEsS0FBWTtFQUM1QyxJQUFJO0lBQ0YsTUFBTXpILFNBQVMsQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLENBQUM7SUFDekMsTUFBTUEsU0FBUyxDQUFDLDJCQUEyQixFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hELE9BQU8sSUFBSTtFQUNiLENBQUMsQ0FBQyxPQUFPc0QsS0FBSyxFQUFFO0lBQ2RDLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLGdDQUFnQyxFQUFFQSxLQUFLLENBQUM7SUFDdEQsT0FBTyxLQUFLO0VBQ2Q7QUFDRixDQUFDOztBQUVEO0FBQ08sTUFBTW9FLDBCQUEwQixHQUFHQSxDQUFBLEtBQU07RUFDOUMsT0FBTztJQUNMeEgsZ0JBQWdCO0lBQ2hCVSxjQUFjO0lBQ2Q0QyxxQkFBcUI7SUFDckI2QixrQkFBa0I7SUFDbEI2QjtFQUNGLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFtYmlzbGVlcC1jaGF0LWFnZW50Ly4vc3JjL3NlcnZpY2VzL2Vtb3Rpb25hbEludGVsbGlnZW5jZS5qcz82NjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVtb3Rpb25hbCBJbnRlbGxpZ2VuY2UgU2VydmljZSAtIENvcmUgZW1vdGlvbiBkZXRlY3Rpb24gYW5kIHBhdHRlcm4gdHJhY2tpbmdcclxuLy8gRm9sbG93aW5nIGNvcGlsb3QtaW5zdHJ1Y3Rpb25zLm1kOiBMb2NhbC1maXJzdCBhcmNoaXRlY3R1cmUgd2l0aCBwcml2YWN5IHByb3RlY3Rpb25cclxuXHJcbmltcG9ydCB7IGdldE1lbW9yeSwgc2V0TWVtb3J5IH0gZnJvbSAnLi9tZW1vcnlTZXJ2aWNlLmpzJztcclxuXHJcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlscy92YWxpZGF0aW9uLmpzJztcclxuXHJcbi8vIEVtb3Rpb24gYW5hbHlzaXMgdXNpbmcgc2VudGltZW50IHBhdHRlcm5zIGFuZCBrZXl3b3JkIGRldGVjdGlvblxyXG5jb25zdCBFTU9USU9OX1BBVFRFUk5TID0ge1xyXG4gIGpveToge1xyXG4gICAga2V5d29yZHM6IFsnaGFwcHknLCAnZXhjaXRlZCcsICd3b25kZXJmdWwnLCAnYW1hemluZycsICdsb3ZlJywgJ2dyZWF0JywgJ2ZhbnRhc3RpYycsICdhd2Vzb21lJywgJ3BlcmZlY3QnLCAnYnJpbGxpYW50J10sXHJcbiAgICBpbnRlbnNpdHlfbW9kaWZpZXJzOiBbJ3ZlcnknLCAnZXh0cmVtZWx5JywgJ2luY3JlZGlibHknLCAnYWJzb2x1dGVseScsICd0b3RhbGx5J10sXHJcbiAgICBlbW9qaV9wYXR0ZXJuczogWyfwn5iKJywgJ/CfmIQnLCAn8J+YgycsICfwn6WwJywgJ/CfmI0nLCAn8J+kqScsICfinKgnLCAn8J+SlicsICfinaTvuI8nLCAn8J+OiSddLFxyXG4gIH0sXHJcbiAgc2FkbmVzczoge1xyXG4gICAga2V5d29yZHM6IFsnc2FkJywgJ3Vwc2V0JywgJ2Rpc2FwcG9pbnRlZCcsICdkb3duJywgJ2h1cnQnLCAnY3J5aW5nJywgJ2RlcHJlc3NlZCcsICdsb25lbHknLCAnZW1wdHknLCAnYnJva2VuJ10sXHJcbiAgICBpbnRlbnNpdHlfbW9kaWZpZXJzOiBbJ3ZlcnknLCAnZXh0cmVtZWx5JywgJ2RlZXBseScsICdjb21wbGV0ZWx5JywgJ3RvdGFsbHknXSxcclxuICAgIGVtb2ppX3BhdHRlcm5zOiBbJ/CfmKInLCAn8J+YrScsICfwn5iUJywgJ+KYue+4jycsICfwn5ieJywgJ/CfkpQnLCAn8J+YsCcsICfwn5ilJywgJ/CfpbonXSxcclxuICB9LFxyXG4gIGFuZ2VyOiB7XHJcbiAgICBrZXl3b3JkczogWydhbmdyeScsICdtYWQnLCAnZnVyaW91cycsICdmcnVzdHJhdGVkJywgJ2Fubm95ZWQnLCAnaXJyaXRhdGVkJywgJ3Bpc3NlZCcsICdyYWdlJywgJ2hhdGUnLCAnZGlzZ3VzdGVkJ10sXHJcbiAgICBpbnRlbnNpdHlfbW9kaWZpZXJzOiBbJ3ZlcnknLCAnZXh0cmVtZWx5JywgJ2luY3JlZGlibHknLCAnYWJzb2x1dGVseScsICdyZWFsbHknXSxcclxuICAgIGVtb2ppX3BhdHRlcm5zOiBbJ/CfmKAnLCAn8J+YoScsICfwn6SsJywgJ/CfmKQnLCAn8J+SoicsICfwn5SlJywgJ/Cfkb8nLCAn8J+YviddLFxyXG4gIH0sXHJcbiAgZmVhcjoge1xyXG4gICAga2V5d29yZHM6IFsnc2NhcmVkJywgJ2FmcmFpZCcsICd3b3JyaWVkJywgJ2FueGlvdXMnLCAnbmVydm91cycsICd0ZXJyaWZpZWQnLCAncGFuaWMnLCAnc3RyZXNzJywgJ2NvbmNlcm5lZCcsICdmcmlnaHRlbmVkJ10sXHJcbiAgICBpbnRlbnNpdHlfbW9kaWZpZXJzOiBbJ3ZlcnknLCAnZXh0cmVtZWx5JywgJ2luY3JlZGlibHknLCAnYWJzb2x1dGVseScsICdyZWFsbHknXSxcclxuICAgIGVtb2ppX3BhdHRlcm5zOiBbJ/CfmKgnLCAn8J+YsCcsICfwn5ixJywgJ/CfmYgnLCAn8J+YpycsICfwn5ifJywgJ/CfmKYnLCAn8J+royddLFxyXG4gIH0sXHJcbiAgc3VycHJpc2U6IHtcclxuICAgIGtleXdvcmRzOiBbJ3N1cnByaXNlZCcsICdzaG9ja2VkJywgJ2FtYXplZCcsICdhc3RvbmlzaGVkJywgJ3VuZXhwZWN0ZWQnLCAnd293JywgJ29tZycsICdpbmNyZWRpYmxlJywgJ3VuYmVsaWV2YWJsZSddLFxyXG4gICAgaW50ZW5zaXR5X21vZGlmaWVyczogWyd2ZXJ5JywgJ2V4dHJlbWVseScsICd0b3RhbGx5JywgJ2NvbXBsZXRlbHknLCAnYWJzb2x1dGVseSddLFxyXG4gICAgZW1vamlfcGF0dGVybnM6IFsn8J+YsicsICfwn5ivJywgJ/CfmK4nLCAn8J+krycsICfwn5i1JywgJ/CfmYAnLCAn8J+YsSddLFxyXG4gIH0sXHJcbiAgbmV1dHJhbDoge1xyXG4gICAga2V5d29yZHM6IFsnb2theScsICdmaW5lJywgJ25vcm1hbCcsICdyZWd1bGFyJywgJ3VzdWFsJywgJ2F2ZXJhZ2UnLCAnc3RhbmRhcmQnXSxcclxuICAgIGludGVuc2l0eV9tb2RpZmllcnM6IFsncHJldHR5JywgJ2ZhaXJseScsICdzb21ld2hhdCcsICdraW5kIG9mJ10sXHJcbiAgICBlbW9qaV9wYXR0ZXJuczogWyfwn5iQJywgJ/CfmJEnLCAn8J+ktycsICfwn5mCJ10sXHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEFkdmFuY2VkIHNlbnRpbWVudCBhbmFseXNpcyB3aXRoIGNvbnRleHQgYXdhcmVuZXNzXHJcbmV4cG9ydCBjb25zdCBhbmFseXplRW1vdGlvbiA9ICh0ZXh0LCBjb250ZXh0ID0ge30pID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF0ZXh0IHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4geyBlbW90aW9uOiAnbmV1dHJhbCcsIGNvbmZpZGVuY2U6IDAuMSwgaW50ZW5zaXR5OiAwLjEgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBub3JtYWxpemVkVGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcbiAgICBjb25zdCB3b3JkcyA9IG5vcm1hbGl6ZWRUZXh0LnNwbGl0KC9cXHMrLyk7XHJcblxyXG4gICAgLy8gU2NvcmUgZWFjaCBlbW90aW9uIGNhdGVnb3J5XHJcbiAgICBjb25zdCBlbW90aW9uU2NvcmVzID0ge307XHJcbiAgICBsZXQgdG90YWxNYXRjaGVzID0gMDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtlbW90aW9uLCBwYXR0ZXJuc10gb2YgT2JqZWN0LmVudHJpZXMoRU1PVElPTl9QQVRURVJOUykpIHtcclxuICAgICAgbGV0IHNjb3JlID0gMDtcclxuICAgICAgbGV0IG1hdGNoZXMgPSAwO1xyXG5cclxuICAgICAgLy8gQ2hlY2sga2V5d29yZHNcclxuICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIHBhdHRlcm5zLmtleXdvcmRzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5d29yZENvdW50ID0gKG5vcm1hbGl6ZWRUZXh0Lm1hdGNoKG5ldyBSZWdFeHAoYFxcXFxiJHtrZXl3b3JkfVxcXFxiYCwgJ2cnKSkgfHwgW10pLmxlbmd0aDtcclxuICAgICAgICBpZiAoa2V5d29yZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgc2NvcmUgKz0ga2V5d29yZENvdW50ICogMS4wO1xyXG4gICAgICAgICAgbWF0Y2hlcyArPSBrZXl3b3JkQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpbnRlbnNpdHkgbW9kaWZpZXJzXHJcbiAgICAgIGZvciAoY29uc3QgbW9kaWZpZXIgb2YgcGF0dGVybnMuaW50ZW5zaXR5X21vZGlmaWVycykge1xyXG4gICAgICAgIGlmIChub3JtYWxpemVkVGV4dC5pbmNsdWRlcyhtb2RpZmllcikpIHtcclxuICAgICAgICAgIHNjb3JlICo9IDEuMzsgLy8gQm9vc3QgaW50ZW5zaXR5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBlbW9qaSBwYXR0ZXJuc1xyXG4gICAgICBmb3IgKGNvbnN0IGVtb2ppIG9mIHBhdHRlcm5zLmVtb2ppX3BhdHRlcm5zKSB7XHJcbiAgICAgICAgY29uc3QgZW1vamlDb3VudCA9ICh0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAoZW1vamksICdnJykpIHx8IFtdKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGVtb2ppQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICBzY29yZSArPSBlbW9qaUNvdW50ICogMC44O1xyXG4gICAgICAgICAgbWF0Y2hlcyArPSBlbW9qaUNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZW1vdGlvblNjb3Jlc1tlbW90aW9uXSA9IHNjb3JlO1xyXG4gICAgICB0b3RhbE1hdGNoZXMgKz0gbWF0Y2hlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIGRvbWluYW50IGVtb3Rpb25cclxuICAgIGNvbnN0IGRvbWluYW50RW1vdGlvbiA9IE9iamVjdC5lbnRyaWVzKGVtb3Rpb25TY29yZXMpLnJlZHVjZSgoYSwgYikgPT5cclxuICAgICAgZW1vdGlvblNjb3Jlc1thWzBdXSA+IGVtb3Rpb25TY29yZXNbYlswXV0gPyBhIDogYixcclxuICAgIClbMF07XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbmZpZGVuY2UgYW5kIGludGVuc2l0eVxyXG4gICAgY29uc3QgbWF4U2NvcmUgPSBlbW90aW9uU2NvcmVzW2RvbWluYW50RW1vdGlvbl07XHJcbiAgICBjb25zdCBjb25maWRlbmNlID0gdG90YWxNYXRjaGVzID4gMCA/IE1hdGgubWluKG1heFNjb3JlIC8gdG90YWxNYXRjaGVzLCAxLjApIDogMC4xO1xyXG4gICAgY29uc3QgaW50ZW5zaXR5ID0gTWF0aC5taW4obWF4U2NvcmUgLyAyLjAsIDEuMCk7XHJcblxyXG4gICAgLy8gQ29udGV4dC1iYXNlZCBhZGp1c3RtZW50c1xyXG4gICAgY29uc3QgYWRqdXN0ZWRFbW90aW9uID0gZG9taW5hbnRFbW90aW9uO1xyXG4gICAgbGV0IGFkanVzdGVkQ29uZmlkZW5jZSA9IGNvbmZpZGVuY2U7XHJcblxyXG4gICAgaWYgKGNvbnRleHQucHJldmlvdXNFbW90aW9uKSB7XHJcbiAgICAgIC8vIEVtb3Rpb25hbCBjb250aW51aXR5IC0gc2xpZ2h0IGJpYXMgdG93YXJkIHByZXZpb3VzIGVtb3Rpb25cclxuICAgICAgaWYgKGNvbnRleHQucHJldmlvdXNFbW90aW9uID09PSBkb21pbmFudEVtb3Rpb24pIHtcclxuICAgICAgICBhZGp1c3RlZENvbmZpZGVuY2UgKj0gMS4xO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnRleHQuY29udmVyc2F0aW9uTGVuZ3RoICYmIGNvbnRleHQuY29udmVyc2F0aW9uTGVuZ3RoID4gMTApIHtcclxuICAgICAgLy8gTG9uZ2VyIGNvbnZlcnNhdGlvbnMgdGVuZCB0byBiZSBtb3JlIG51YW5jZWRcclxuICAgICAgYWRqdXN0ZWRDb25maWRlbmNlICo9IDAuOTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbW90aW9uOiBhZGp1c3RlZEVtb3Rpb24sXHJcbiAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWF4KDAuMSwgTWF0aC5taW4oYWRqdXN0ZWRDb25maWRlbmNlLCAxLjApKSxcclxuICAgICAgaW50ZW5zaXR5OiBNYXRoLm1heCgwLjEsIE1hdGgubWluKGludGVuc2l0eSwgMS4wKSksXHJcbiAgICAgIHJhd1Njb3JlczogZW1vdGlvblNjb3JlcyxcclxuICAgICAgbWF0Y2hlczogdG90YWxNYXRjaGVzLFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVtb3Rpb24gYW5hbHlzaXM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgZW1vdGlvbjogJ25ldXRyYWwnLCBjb25maWRlbmNlOiAwLjEsIGludGVuc2l0eTogMC4xIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVHJhY2sgZW1vdGlvbmFsIHBhdHRlcm5zIG92ZXIgdGltZVxyXG5leHBvcnQgY29uc3QgdHJhY2tFbW90aW9uYWxQYXR0ZXJuID0gYXN5bmMgKGVtb3Rpb24sIGludGVuc2l0eSwgY29udGV4dCA9IHt9KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgIGNvbnN0IHBhdHRlcm5FbnRyeSA9IHtcclxuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgZW1vdGlvbixcclxuICAgICAgaW50ZW5zaXR5LFxyXG4gICAgICB0aW1lc3RhbXAsXHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdldCBleGlzdGluZyBwYXR0ZXJuc1xyXG4gICAgY29uc3QgZXhpc3RpbmdQYXR0ZXJucyA9IGF3YWl0IGdldE1lbW9yeSgnZW1vdGlvbmFsX3BhdHRlcm5zJykgfHwgW107XHJcblxyXG4gICAgLy8gQWRkIG5ldyBwYXR0ZXJuXHJcbiAgICBleGlzdGluZ1BhdHRlcm5zLnB1c2gocGF0dGVybkVudHJ5KTtcclxuXHJcbiAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAgcGF0dGVybnMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICBjb25zdCByZWNlbnRQYXR0ZXJucyA9IGV4aXN0aW5nUGF0dGVybnMuc2xpY2UoLTEwMCk7XHJcblxyXG4gICAgLy8gU2F2ZSB1cGRhdGVkIHBhdHRlcm5zXHJcbiAgICBhd2FpdCBzZXRNZW1vcnkoJ2Vtb3Rpb25hbF9wYXR0ZXJucycsIHJlY2VudFBhdHRlcm5zKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgZGFpbHkgc3VtbWFyeVxyXG4gICAgYXdhaXQgdXBkYXRlRGFpbHlTdW1tYXJ5KGVtb3Rpb24sIGludGVuc2l0eSk7XHJcblxyXG4gICAgcmV0dXJuIHBhdHRlcm5FbnRyeTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyYWNraW5nIGVtb3Rpb25hbCBwYXR0ZXJuOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBkYWlseSBlbW90aW9uYWwgc3VtbWFyeVxyXG5jb25zdCB1cGRhdGVEYWlseVN1bW1hcnkgPSBhc3luYyAoZW1vdGlvbiwgaW50ZW5zaXR5KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKTtcclxuICAgIGNvbnN0IGRhaWx5U3VtbWFyaWVzID0gYXdhaXQgZ2V0TWVtb3J5KCdkYWlseV9lbW90aW9uYWxfc3VtbWFyaWVzJykgfHwge307XHJcblxyXG4gICAgaWYgKCFkYWlseVN1bW1hcmllc1t0b2RheV0pIHtcclxuICAgICAgZGFpbHlTdW1tYXJpZXNbdG9kYXldID0ge1xyXG4gICAgICAgIGRhdGU6IHRvZGF5LFxyXG4gICAgICAgIGVtb3Rpb25zOiB7fSxcclxuICAgICAgICB0b3RhbEVudHJpZXM6IDAsXHJcbiAgICAgICAgYXZlcmFnZUludGVuc2l0eTogMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b2RheVN1bW1hcnkgPSBkYWlseVN1bW1hcmllc1t0b2RheV07XHJcblxyXG4gICAgLy8gVXBkYXRlIGVtb3Rpb24gY291bnRzXHJcbiAgICBpZiAoIXRvZGF5U3VtbWFyeS5lbW90aW9uc1tlbW90aW9uXSkge1xyXG4gICAgICB0b2RheVN1bW1hcnkuZW1vdGlvbnNbZW1vdGlvbl0gPSB7IGNvdW50OiAwLCB0b3RhbEludGVuc2l0eTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHRvZGF5U3VtbWFyeS5lbW90aW9uc1tlbW90aW9uXS5jb3VudCsrO1xyXG4gICAgdG9kYXlTdW1tYXJ5LmVtb3Rpb25zW2Vtb3Rpb25dLnRvdGFsSW50ZW5zaXR5ICs9IGludGVuc2l0eTtcclxuICAgIHRvZGF5U3VtbWFyeS50b3RhbEVudHJpZXMrKztcclxuXHJcbiAgICAvLyBSZWNhbGN1bGF0ZSBhdmVyYWdlIGludGVuc2l0eVxyXG4gICAgY29uc3QgdG90YWxJbnRlbnNpdHkgPSBPYmplY3QudmFsdWVzKHRvZGF5U3VtbWFyeS5lbW90aW9ucylcclxuICAgICAgLnJlZHVjZSgoc3VtLCBlbW90aW9uRGF0YSkgPT4gc3VtICsgZW1vdGlvbkRhdGEudG90YWxJbnRlbnNpdHksIDApO1xyXG4gICAgdG9kYXlTdW1tYXJ5LmF2ZXJhZ2VJbnRlbnNpdHkgPSB0b3RhbEludGVuc2l0eSAvIHRvZGF5U3VtbWFyeS50b3RhbEVudHJpZXM7XHJcblxyXG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMzAgZGF5c1xyXG4gICAgY29uc3QgdGhpcnR5RGF5c0FnbyA9IG5ldyBEYXRlKCk7XHJcbiAgICB0aGlydHlEYXlzQWdvLnNldERhdGUodGhpcnR5RGF5c0Fnby5nZXREYXRlKCkgLSAzMCk7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyZWRTdW1tYXJpZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3QgW2RhdGUsIHN1bW1hcnldIG9mIE9iamVjdC5lbnRyaWVzKGRhaWx5U3VtbWFyaWVzKSkge1xyXG4gICAgICBpZiAobmV3IERhdGUoZGF0ZSkgPj0gdGhpcnR5RGF5c0Fnbykge1xyXG4gICAgICAgIGZpbHRlcmVkU3VtbWFyaWVzW2RhdGVdID0gc3VtbWFyeTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHNldE1lbW9yeSgnZGFpbHlfZW1vdGlvbmFsX3N1bW1hcmllcycsIGZpbHRlcmVkU3VtbWFyaWVzKTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGRhaWx5IHN1bW1hcnk6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEdldCBlbW90aW9uYWwgdHJlbmRzIGFuZCBpbnNpZ2h0c1xyXG5leHBvcnQgY29uc3QgZ2V0RW1vdGlvbmFsVHJlbmRzID0gYXN5bmMgKGRheXMgPSA3KSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHBhdHRlcm5zID0gYXdhaXQgZ2V0TWVtb3J5KCdlbW90aW9uYWxfcGF0dGVybnMnKSB8fCBbXTtcclxuICAgIGNvbnN0IGRhaWx5U3VtbWFyaWVzID0gYXdhaXQgZ2V0TWVtb3J5KCdkYWlseV9lbW90aW9uYWxfc3VtbWFyaWVzJykgfHwge307XHJcblxyXG4gICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBjdXRvZmZEYXRlLnNldERhdGUoY3V0b2ZmRGF0ZS5nZXREYXRlKCkgLSBkYXlzKTtcclxuXHJcbiAgICAvLyBGaWx0ZXIgcmVjZW50IHBhdHRlcm5zXHJcbiAgICBjb25zdCByZWNlbnRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcihwYXR0ZXJuID0+XHJcbiAgICAgIHBhdHRlcm4gJiYgcGF0dGVybi50aW1lc3RhbXAgJiYgbmV3IERhdGUocGF0dGVybi50aW1lc3RhbXApID49IGN1dG9mZkRhdGUsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0cmVuZHNcclxuICAgIGNvbnN0IGVtb3Rpb25Db3VudHMgPSB7fTtcclxuICAgIGxldCB0b3RhbEludGVuc2l0eSA9IDA7XHJcbiAgICBjb25zdCB0b3RhbEVudHJpZXMgPSByZWNlbnRQYXR0ZXJucy5sZW5ndGg7XHJcblxyXG4gICAgcmVjZW50UGF0dGVybnMuZm9yRWFjaChwYXR0ZXJuID0+IHtcclxuICAgICAgaWYgKHBhdHRlcm4gJiYgcGF0dGVybi5lbW90aW9uKSB7XHJcbiAgICAgICAgaWYgKCFlbW90aW9uQ291bnRzW3BhdHRlcm4uZW1vdGlvbl0pIHtcclxuICAgICAgICAgIGVtb3Rpb25Db3VudHNbcGF0dGVybi5lbW90aW9uXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVtb3Rpb25Db3VudHNbcGF0dGVybi5lbW90aW9uXSsrO1xyXG4gICAgICAgIHRvdGFsSW50ZW5zaXR5ICs9IHBhdHRlcm4uaW50ZW5zaXR5IHx8IDA7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdldCBkb21pbmFudCBlbW90aW9uc1xyXG4gICAgY29uc3Qgc29ydGVkRW1vdGlvbnMgPSBPYmplY3QuZW50cmllcyhlbW90aW9uQ291bnRzKVxyXG4gICAgICAuc29ydCgoWywgYV0sIFssIGJdKSA9PiBiIC0gYSlcclxuICAgICAgLnNsaWNlKDAsIDMpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBlbW90aW9uYWwgc3RhYmlsaXR5ICh2YXJpYW5jZSBpbiBlbW90aW9ucylcclxuICAgIGNvbnN0IGVtb3Rpb25WYXJpZXR5ID0gT2JqZWN0LmtleXMoZW1vdGlvbkNvdW50cykubGVuZ3RoO1xyXG4gICAgY29uc3Qgc3RhYmlsaXR5ID0gZW1vdGlvblZhcmlldHkgPiAwID8gMSAvIGVtb3Rpb25WYXJpZXR5IDogMTtcclxuXHJcbiAgICAvLyBHZXQgZGFpbHkgdHJlbmRzXHJcbiAgICBjb25zdCBkYWlseVRyZW5kcyA9IE9iamVjdC52YWx1ZXMoZGFpbHlTdW1tYXJpZXMpXHJcbiAgICAgIC5maWx0ZXIoc3VtbWFyeSA9PiBzdW1tYXJ5ICYmIHN1bW1hcnkuZGF0ZSAmJiBuZXcgRGF0ZShzdW1tYXJ5LmRhdGUpID49IGN1dG9mZkRhdGUpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpIC0gbmV3IERhdGUoYi5kYXRlKSk7XHJcblxyXG4gICAgLy8gR2V0IGRvbWluYW50IGVtb3Rpb25cclxuICAgIGNvbnN0IGRvbWluYW50RW1vdGlvbiA9IHNvcnRlZEVtb3Rpb25zLmxlbmd0aCA+IDAgPyBzb3J0ZWRFbW90aW9uc1swXVswXSA6ICduZXV0cmFsJztcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEVudHJpZXMsXHJcbiAgICAgIGF2ZXJhZ2VJbnRlbnNpdHk6IHRvdGFsRW50cmllcyA+IDAgPyB0b3RhbEludGVuc2l0eSAvIHRvdGFsRW50cmllcyA6IDAsXHJcbiAgICAgIGRvbWluYW50RW1vdGlvbixcclxuICAgICAgZG9taW5hbnRFbW90aW9uczogc29ydGVkRW1vdGlvbnMubWFwKChbZW1vdGlvbiwgY291bnRdKSA9PiAoe1xyXG4gICAgICAgIGVtb3Rpb24sXHJcbiAgICAgICAgY291bnQsXHJcbiAgICAgICAgcGVyY2VudGFnZTogdG90YWxFbnRyaWVzID4gMCA/IChjb3VudCAvIHRvdGFsRW50cmllcykgKiAxMDAgOiAwLFxyXG4gICAgICB9KSksXHJcbiAgICAgIGVtb3Rpb25hbFN0YWJpbGl0eTogc3RhYmlsaXR5LFxyXG4gICAgICBlbW90aW9uVmFyaWV0eSxcclxuICAgICAgZGFpbHlUcmVuZHMsXHJcbiAgICAgIHRyZW5kczogZW1vdGlvbkNvdW50cyxcclxuICAgICAgcmVjb21tZW5kYXRpb25zOiBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhlbW90aW9uQ291bnRzLCB0b3RhbEVudHJpZXMgPiAwID8gdG90YWxJbnRlbnNpdHkgLyB0b3RhbEVudHJpZXMgOiAwKSxcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGVtb3Rpb25hbCB0cmVuZHM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxFbnRyaWVzOiAwLFxyXG4gICAgICBhdmVyYWdlSW50ZW5zaXR5OiAwLFxyXG4gICAgICBkb21pbmFudEVtb3Rpb246ICduZXV0cmFsJyxcclxuICAgICAgZG9taW5hbnRFbW90aW9uczogW10sXHJcbiAgICAgIGVtb3Rpb25hbFN0YWJpbGl0eTogMSxcclxuICAgICAgZW1vdGlvblZhcmlldHk6IDAsXHJcbiAgICAgIGRhaWx5VHJlbmRzOiBbXSxcclxuICAgICAgdHJlbmRzOiB7fSxcclxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2VuZXJhdGUgZW1vdGlvbmFsIGhlYWx0aCByZWNvbW1lbmRhdGlvbnNcclxuY29uc3QgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMgPSAoZW1vdGlvbkNvdW50cywgYXZlcmFnZUludGVuc2l0eSkgPT4ge1xyXG4gIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IFtdO1xyXG5cclxuICAvLyBDaGVjayBmb3IgZW1vdGlvbmFsIGJhbGFuY2VcclxuICBjb25zdCB0b3RhbEVtb3Rpb25zID0gT2JqZWN0LnZhbHVlcyhlbW90aW9uQ291bnRzKS5yZWR1Y2UoKHN1bSwgY291bnQpID0+IHN1bSArIGNvdW50LCAwKTtcclxuICBjb25zdCBuZWdhdGl2ZUVtb3Rpb25zID0gWydzYWRuZXNzJywgJ2FuZ2VyJywgJ2ZlYXInXTtcclxuICBjb25zdCBuZWdhdGl2ZUNvdW50ID0gbmVnYXRpdmVFbW90aW9ucy5yZWR1Y2UoKHN1bSwgZW1vdGlvbikgPT5cclxuICAgIHN1bSArIChlbW90aW9uQ291bnRzW2Vtb3Rpb25dIHx8IDApLCAwKTtcclxuXHJcbiAgaWYgKG5lZ2F0aXZlQ291bnQgLyB0b3RhbEVtb3Rpb25zID4gMC42KSB7XHJcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgIHR5cGU6ICdlbW90aW9uYWxfYmFsYW5jZScsXHJcbiAgICAgIG1lc3NhZ2U6ICdDb25zaWRlciBhY3Rpdml0aWVzIHRoYXQgYnJpbmcgeW91IGpveSAtIG11c2ljLCBuYXR1cmUsIG9yIGNvbm5lY3Rpbmcgd2l0aCBsb3ZlZCBvbmVzLicsXHJcbiAgICAgIHByaW9yaXR5OiAnaGlnaCcsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChhdmVyYWdlSW50ZW5zaXR5ID4gMC44KSB7XHJcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgIHR5cGU6ICdpbnRlbnNpdHlfbWFuYWdlbWVudCcsXHJcbiAgICAgIG1lc3NhZ2U6ICdZb3VyIGVtb3Rpb25zIGFyZSBydW5uaW5nIGhpZ2guIERlZXAgYnJlYXRoaW5nIG9yIG1lZGl0YXRpb24gbWlnaHQgaGVscC4nLFxyXG4gICAgICBwcmlvcml0eTogJ21lZGl1bScsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICgoZW1vdGlvbkNvdW50cy5qb3kgfHwgMCkgLyB0b3RhbEVtb3Rpb25zID4gMC43KSB7XHJcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgIHR5cGU6ICdwb3NpdGl2ZV9yZWluZm9yY2VtZW50JyxcclxuICAgICAgbWVzc2FnZTogJ1lvdSBzZWVtIHRvIGJlIGluIGEgZ3JlYXQgZW1vdGlvbmFsIHNwYWNlISBLZWVwIGRvaW5nIHdoYXQgbWFrZXMgeW91IGhhcHB5LicsXHJcbiAgICAgIHByaW9yaXR5OiAnbG93JyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcclxufTtcclxuXHJcbi8vIEdldCBtb29kLWFwcHJvcHJpYXRlIHJlc3BvbnNlIHRvbmVcclxuZXhwb3J0IGNvbnN0IGdldE1vb2RBcHByb3ByaWF0ZVJlc3BvbnNlID0gKHVzZXJFbW90aW9uLCBpbnRlbnNpdHkpID0+IHtcclxuICBjb25zdCB0b25lTWFwID0ge1xyXG4gICAgam95OiB7XHJcbiAgICAgIGxvdzogJ3dhcm0nLFxyXG4gICAgICBtZWRpdW06ICdlbnRodXNpYXN0aWMnLFxyXG4gICAgICBoaWdoOiAnY2VsZWJyYXRvcnknLFxyXG4gICAgfSxcclxuICAgIHNhZG5lc3M6IHtcclxuICAgICAgbG93OiAnZ2VudGxlJyxcclxuICAgICAgbWVkaXVtOiAnc3VwcG9ydGl2ZScsXHJcbiAgICAgIGhpZ2g6ICdjb21mb3J0aW5nJyxcclxuICAgIH0sXHJcbiAgICBhbmdlcjoge1xyXG4gICAgICBsb3c6ICd1bmRlcnN0YW5kaW5nJyxcclxuICAgICAgbWVkaXVtOiAndmFsaWRhdGluZycsXHJcbiAgICAgIGhpZ2g6ICdjYWxtaW5nJyxcclxuICAgIH0sXHJcbiAgICBmZWFyOiB7XHJcbiAgICAgIGxvdzogJ3JlYXNzdXJpbmcnLFxyXG4gICAgICBtZWRpdW06ICdwcm90ZWN0aXZlJyxcclxuICAgICAgaGlnaDogJ2dyb3VuZGluZycsXHJcbiAgICB9LFxyXG4gICAgc3VycHJpc2U6IHtcclxuICAgICAgbG93OiAnY3VyaW91cycsXHJcbiAgICAgIG1lZGl1bTogJ2VuZ2FnZWQnLFxyXG4gICAgICBoaWdoOiAnZXhjaXRlZCcsXHJcbiAgICB9LFxyXG4gICAgbmV1dHJhbDoge1xyXG4gICAgICBsb3c6ICdjYXN1YWwnLFxyXG4gICAgICBtZWRpdW06ICdmcmllbmRseScsXHJcbiAgICAgIGhpZ2g6ICdlbmdhZ2luZycsXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGludGVuc2l0eUxldmVsID0gaW50ZW5zaXR5IDw9IDAuMyA/ICdsb3cnIDogaW50ZW5zaXR5IDw9IDAuNyA/ICdtZWRpdW0nIDogJ2hpZ2gnO1xyXG4gIHJldHVybiB0b25lTWFwW3VzZXJFbW90aW9uXT8uW2ludGVuc2l0eUxldmVsXSB8fCAnZnJpZW5kbHknO1xyXG59O1xyXG5cclxuLy8gQ2xlYXIgZW1vdGlvbmFsIGRhdGEgKGZvciBwcml2YWN5KVxyXG5leHBvcnQgY29uc3QgY2xlYXJFbW90aW9uYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBzZXRNZW1vcnkoJ2Vtb3Rpb25hbF9wYXR0ZXJucycsIFtdKTtcclxuICAgIGF3YWl0IHNldE1lbW9yeSgnZGFpbHlfZW1vdGlvbmFsX3N1bW1hcmllcycsIHt9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBlbW90aW9uYWwgZGF0YTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRXhwb3J0IGZ1bmN0aW9ucyBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nXHJcbmV4cG9ydCBjb25zdCBkZWJ1Z0Vtb3Rpb25hbEludGVsbGlnZW5jZSA9ICgpID0+IHtcclxuICByZXR1cm4ge1xyXG4gICAgRU1PVElPTl9QQVRURVJOUyxcclxuICAgIGFuYWx5emVFbW90aW9uLFxyXG4gICAgdHJhY2tFbW90aW9uYWxQYXR0ZXJuLFxyXG4gICAgZ2V0RW1vdGlvbmFsVHJlbmRzLFxyXG4gICAgZ2V0TW9vZEFwcHJvcHJpYXRlUmVzcG9uc2UsXHJcbiAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbImdldE1lbW9yeSIsInNldE1lbW9yeSIsImdlbmVyYXRlSWQiLCJFTU9USU9OX1BBVFRFUk5TIiwiam95Iiwia2V5d29yZHMiLCJpbnRlbnNpdHlfbW9kaWZpZXJzIiwiZW1vamlfcGF0dGVybnMiLCJzYWRuZXNzIiwiYW5nZXIiLCJmZWFyIiwic3VycHJpc2UiLCJuZXV0cmFsIiwiYW5hbHl6ZUVtb3Rpb24iLCJ0ZXh0IiwiY29udGV4dCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImVtb3Rpb24iLCJjb25maWRlbmNlIiwiaW50ZW5zaXR5Iiwibm9ybWFsaXplZFRleHQiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJ3b3JkcyIsInNwbGl0IiwiZW1vdGlvblNjb3JlcyIsInRvdGFsTWF0Y2hlcyIsInBhdHRlcm5zIiwiT2JqZWN0IiwiZW50cmllcyIsInNjb3JlIiwibWF0Y2hlcyIsImtleXdvcmQiLCJrZXl3b3JkQ291bnQiLCJtYXRjaCIsIlJlZ0V4cCIsIm1vZGlmaWVyIiwiaW5jbHVkZXMiLCJlbW9qaSIsImVtb2ppQ291bnQiLCJkb21pbmFudEVtb3Rpb24iLCJyZWR1Y2UiLCJhIiwiYiIsIm1heFNjb3JlIiwiTWF0aCIsIm1pbiIsImFkanVzdGVkRW1vdGlvbiIsImFkanVzdGVkQ29uZmlkZW5jZSIsInByZXZpb3VzRW1vdGlvbiIsImNvbnZlcnNhdGlvbkxlbmd0aCIsIm1heCIsInJhd1Njb3JlcyIsImVycm9yIiwiY29uc29sZSIsInRyYWNrRW1vdGlvbmFsUGF0dGVybiIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBhdHRlcm5FbnRyeSIsImlkIiwiZGF0ZSIsInRvRGF0ZVN0cmluZyIsImV4aXN0aW5nUGF0dGVybnMiLCJwdXNoIiwicmVjZW50UGF0dGVybnMiLCJzbGljZSIsInVwZGF0ZURhaWx5U3VtbWFyeSIsInRvZGF5IiwiZGFpbHlTdW1tYXJpZXMiLCJlbW90aW9ucyIsInRvdGFsRW50cmllcyIsImF2ZXJhZ2VJbnRlbnNpdHkiLCJ0b2RheVN1bW1hcnkiLCJjb3VudCIsInRvdGFsSW50ZW5zaXR5IiwidmFsdWVzIiwic3VtIiwiZW1vdGlvbkRhdGEiLCJ0aGlydHlEYXlzQWdvIiwic2V0RGF0ZSIsImdldERhdGUiLCJmaWx0ZXJlZFN1bW1hcmllcyIsInN1bW1hcnkiLCJnZXRFbW90aW9uYWxUcmVuZHMiLCJkYXlzIiwiY3V0b2ZmRGF0ZSIsImZpbHRlciIsInBhdHRlcm4iLCJlbW90aW9uQ291bnRzIiwiZm9yRWFjaCIsInNvcnRlZEVtb3Rpb25zIiwic29ydCIsIl9yZWYiLCJfcmVmMiIsImVtb3Rpb25WYXJpZXR5Iiwia2V5cyIsInN0YWJpbGl0eSIsImRhaWx5VHJlbmRzIiwiZG9taW5hbnRFbW90aW9ucyIsIm1hcCIsIl9yZWYzIiwicGVyY2VudGFnZSIsImVtb3Rpb25hbFN0YWJpbGl0eSIsInRyZW5kcyIsInJlY29tbWVuZGF0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwidG90YWxFbW90aW9ucyIsIm5lZ2F0aXZlRW1vdGlvbnMiLCJuZWdhdGl2ZUNvdW50IiwidHlwZSIsIm1lc3NhZ2UiLCJwcmlvcml0eSIsImdldE1vb2RBcHByb3ByaWF0ZVJlc3BvbnNlIiwidXNlckVtb3Rpb24iLCJ0b25lTWFwIiwibG93IiwibWVkaXVtIiwiaGlnaCIsImludGVuc2l0eUxldmVsIiwiY2xlYXJFbW90aW9uYWxEYXRhIiwiZGVidWdFbW90aW9uYWxJbnRlbGxpZ2VuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8839\n\n}");

/***/ })

}]);